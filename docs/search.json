[
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "Blog",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n     \n  \n\n\n\n\n\n\n\n\n\n\nHow to generate social share buttons\n\n\n2 min\n\n\n\nRafiq Islam\n\n\nWednesday, July 17, 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWelcome to my blog\n\n\n1 min\n\n\n\nRafiq Islam\n\n\nFriday, July 12, 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMatrix multiplication: Let’s make it less expensive!\n\n\n6 min\n\n\n\nRafiq Islam\n\n\nMonday, July 1, 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nUnderstanding Stochastic Gradient Descent Using Simple Linear Regression\n\n\n5 min\n\n\n\nRafiq Islam\n\n\nSaturday, May 25, 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLU Factorization of a Full rank Matrix using Fortran\n\n\n26 min\n\n\n\nRafiq Islam\n\n\nTuesday, November 9, 2021\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nModeling viral disease\n\n\n3 min\n\n\n\nRafiq Islam\n\n\nTuesday, February 23, 2021\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGeneralized eigenvectors and eigenspaces\n\n\n2 min\n\n\n\nRafiq Islam\n\n\nMonday, January 25, 2021\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSome Linear Algebra Proofs\n\n\n6 min\n\n\n\nRafiq Islam\n\n\nSunday, January 24, 2021\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMatrix Representation: Change of Basis\n\n\n3 min\n\n\n\nRafiq Islam\n\n\nThursday, January 21, 2021\n\n\n\n\n\n\n\n\nNo matching items\n\n Back to top"
  },
  {
    "objectID": "cv.html",
    "href": "cv.html",
    "title": "CV",
    "section": "",
    "text": "Download a PDF"
  },
  {
    "objectID": "cv.html#education",
    "href": "cv.html#education",
    "title": "CV",
    "section": "Education",
    "text": "Education\n\nPh.D in Mathematics, Florida State University; Florida, USA 2026 (expected)\nM.S. in Mathematics, Youngstown State University; Ohio, USA 2020\nM.S. in Applied Mathematics, University of Dhaka; Dhaka, Bangladesh 2016\nB.S. in Mathematics, University of Dhaka; Dhaka, Bangladesh 2014"
  },
  {
    "objectID": "cv.html#work-experience",
    "href": "cv.html#work-experience",
    "title": "CV",
    "section": "Work experience",
    "text": "Work experience\n\nGraduate Teaching Assistant (Fall 2021- To Date)\n\nFlorida State University\nDuties includes: Teaching, Proctoring, and Grading\nSupervisor: Penelope Kirby, Ph.D\n\nGraduate Teaching Assistant (Fall 2018 - Spring 2020)\n\nYoungstown State University University\nDuties included: Teaching, Proctoring, and Grading\nSupervisor: G. Jay Kerns, Ph.D\n\nAssistant Vice President (September 2017 - July 2018)\n\nDelta Life Insurance Company Ltd. Dhaka, Bangladesh\nDuties included: Calculated all types of claims (death, surrender, and maturity) using excel spreadsheets.\nProcessed approximately 500 claims each week and submitted corresponding statistical reports to the higher authority.\nWorked in a team to develop a new short-term endowment assurance product which played an important role to increase the company’s new business.\nRefurbished a without risk endowment product which was out of the sale. Priced insurance premiums based on different risk factors for bigger clients which impacted our life fund significantly.\nCalculated reserves for group endowment, term and premium back policies which was a vital part of the final valuation report.\nLiaised directly with the consulting actuary and provided all sorts of technical and documental supports during actuarial valuation\nSupervisor: Md. Salahuddin Soud, VP"
  },
  {
    "objectID": "cv.html#skills",
    "href": "cv.html#skills",
    "title": "CV",
    "section": "Skills",
    "text": "Skills\n\nLanguage\n\nBengali: Native\nEnglish: Fluent\n\nComputer Literacy\n\nProgramming Languages: Python, FORTRAN, Julia, R, MATLAB, Mathematica\nSoftware Development Tools: Git, GitHub, PyPi\n\nMusical Instrument: Amateur/Novice Bamboo flute player"
  },
  {
    "objectID": "cv.html#publications",
    "href": "cv.html#publications",
    "title": "CV",
    "section": "Publications",
    "text": "Publications\n\nGJR-GARCH Volatility Modeling under NIG and ANN for Predicting Top Cryptocurrencies \nMostafa, F; Saha, P; Islam, Mohammad R.; Nguyen, N. (2020) “Comparison of financial models for stock price prediction.” Journal of Risk and Financial Management.\nComparison of Financial Models for Stock Price Prediction \nIslam, Mohammad R.; Nguyen, N. (2020) “Comparison of financial models for stock price prediction.” Journal of Risk and Financial Management."
  },
  {
    "objectID": "cv.html#talks-and-presentations",
    "href": "cv.html#talks-and-presentations",
    "title": "CV",
    "section": "Talks and Presentations",
    "text": "Talks and Presentations\n\n The Heavy-Tail Phenomenon in Decentralized Stochastic Gradient Descent\nNovember 20, 2023\nPresentation at James J Love Building, Florida State University, Tallahassee, Florida\n\n Decentralized Stochastic Gradient Langevin Dynamics and Hamiltonian Monte Carlo\nOctober 05, 2023\nPresentation at James J Love Building, Florida State University, Tallahassee, Florida\n\n Sensitivity analysis for Monte Carlo and Quasi Monte Carlo option pricing\nApril 28, 2020\nPresentation at Cafaro Hall, Youngstown State University, Youngstown, Ohio"
  },
  {
    "objectID": "cv.html#teaching",
    "href": "cv.html#teaching",
    "title": "CV",
    "section": "Teaching",
    "text": "Teaching\n\n Spring 2024: MAP4170 Introduction to Actuarial Mathematics\n\n Fall 2023: MAP4170 Introduction to Actuarial Mathematics\n\n Spring 2023: MAC1140 PreCalculus Algebra\n\n Fall 2022: MAC2311 Calculus and Analytic Geometry I\n\n Fall 2021 and Spring 2022: PreCalculus and Algebra\n\n Fall 2018 to Spring 2020: College Algebra, Trigonometry"
  },
  {
    "objectID": "cv.html#awards-and-affiliations",
    "href": "cv.html#awards-and-affiliations",
    "title": "CV",
    "section": "Awards and Affiliations",
    "text": "Awards and Affiliations\n\nAwards\n\nBettye Anne Busbee Case Graduate Fellowship & Doctoral Mentorship Recognition 2024\n\nOutstanding Graduate Student in Statistics Award for the 2019-2020 academic year, Youngstown State University.\n\nGraduate College Premiere Scholarship, Youngstown State University.\n\nMetLife Bangladesh Actuarial Study Program 2015\n\n\n\nAffiliations\n\nBangladesh Mathematical Society: Life Member\nSociety of Actuaries, SOA: Student Member\nAmerican Mathematical Society, AMS\nSociety for Industrial and Applied Mathematics"
  },
  {
    "objectID": "portfolio/desgld/index.html",
    "href": "portfolio/desgld/index.html",
    "title": "Python Application Library: desgld packaging",
    "section": "",
    "text": "This package is related to my ongoing project “EXTRA decentralized stochastic gradient Langevin dynamics”. The detail of the package can be found here\nShare on\n\n\n\n\n\n\nShare\n\n\n\nTweet\n\n\n\n\n\n\n\n\n\n\n Back to topCitationBibTeX citation:@online{islam2024,\n  author = {Islam, Rafiq},\n  title = {Python {Application} {Library:} Desgld Packaging},\n  date = {2024-05-03},\n  url = {https://mrislambd.github.io/portfolio/desgld/},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nIslam, Rafiq. 2024. “Python Application Library: Desgld\nPackaging.” May 3, 2024. https://mrislambd.github.io/portfolio/desgld/."
  },
  {
    "objectID": "teaching/fall21.html",
    "href": "teaching/fall21.html",
    "title": "Fall 2021 and Spring 2022: PreCalculus and Algebra",
    "section": "",
    "text": "As a lecture TA, my job was to facilitate the instructor during the class. This included helping students in class activities such as answering short questions that counted as class attendance, checking students’ eligibility forms for taking this course, and others as needed by the instructor.  As a lab TA I worked in a computer lab where students take their weekly quizzes and midterm tests.\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "teaching/fall22.html",
    "href": "teaching/fall22.html",
    "title": "Fall 2022: MAC2311 Calculus and Analytic Geometry I",
    "section": "",
    "text": "Students who have substantial knowledge of precalculus and algebra may require to take this course as a mathematics requirement depending on their majors. The topic of this course includes but is not limited to Foundation for calculus: Functions and Limits, Derivative, The Definite Integral, and Constructing Antiderivatives.  As a recitation instructor for this course, I ran two poster presentation sessions of 30 students in each group where they presented mathematical problems and their solutions step by step to their peer classmates followed by a group activity where they solved another set of problems. I also graded their exam scripts and weekly posters.\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "teaching/sp24.html",
    "href": "teaching/sp24.html",
    "title": "Spring 2024: MAP4170 Introduction to Actuarial Mathematics",
    "section": "",
    "text": "One of the course objectives is for each student to develop a mastery of financial mathematics used by actuaries, based on the mathematics of interest theory. Other course objectives are for each student to understand the long-term individual study commitment necessary to achieve a designation within one of the actuarial societies and for each student to increase their knowledge of the actuarial profession\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "share.html",
    "href": "share.html",
    "title": "",
    "section": "",
    "text": "CodeShow All CodeHide All Code\n\n\n\n\n\n\nCode\nimport urllib.parse\n\n\n\n\nCode\ndef fblink(link):\n    base_url = \"https://www.facebook.com/sharer/sharer.php\"\n    encoded_url = urllib.parse.quote(link, safe='')\n    full_url= f\"{base_url}?u={encoded_url}&amp;src=sdkpreparse\"\n    return full_url\n\n\n\n\nCode\nlink=\"https://mrislambd.github.io/posts/some-proofs/\"\n\n\n\n\nCode\nprint('&lt;div id=\"fb-root\"&gt;&lt;/div&gt;')\nprint('&lt;script async defer crossorigin=\"anonymous\"\\n src=\"https://connect.facebook.net/en_US/sdk.js#xfbml=1&version=v20.0\"&gt;&lt;/script&gt;')\nprint(' ')\nprint('&lt;div class=\"share-buttons\"&gt;')\nprint('&lt;div class=\"fb-share-button\" data-href=\"{}\"'.format(link))\nprint('data-layout=\"button_count\" data-size=\"small\"&gt;&lt;a target=\"_blank\" \\n href=\"{}\" \\n class=\"fb-xfbml-parse-ignore\"&gt;Share&lt;/a&gt;&lt;/div&gt;'.format(fblink(link)))\nprint('')\nprint('&lt;script src=\"https://platform.linkedin.com/in.js\" type=\"text/javascript\"&gt;lang: en_US&lt;/script&gt;')\nprint('&lt;script type=\"IN/Share\" data-url=\"{}\"&gt;&lt;/script&gt; '.format(link)) \nprint(' ')\nprint('&lt;a href=\"https://twitter.com/share?ref_src=twsrc%5Etfw\" class=\"twitter-share-button\" \\n data-url=\"{}\" data-show-count=\"true\"&gt;Tweet&lt;/a&gt;'.format(link))\nprint('&lt;script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"&gt;&lt;/script&gt;')\nprint('&lt;/div&gt;')\nprint('')\nprint('&lt;div class=\"fb-comments\" data-href=\"{}\"\\n data-width=\"\" data-numposts=\"5\"&gt;&lt;/div&gt;'.format(link))\n\n\n&lt;div id=\"fb-root\"&gt;&lt;/div&gt;\n&lt;script async defer crossorigin=\"anonymous\"\n src=\"https://connect.facebook.net/en_US/sdk.js#xfbml=1&version=v20.0\"&gt;&lt;/script&gt;\n \n&lt;div class=\"share-buttons\"&gt;\n&lt;div class=\"fb-share-button\" data-href=\"https://mrislambd.github.io/posts/some-proofs/\"\ndata-layout=\"button_count\" data-size=\"small\"&gt;&lt;a target=\"_blank\" \n href=\"https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fmrislambd.github.io%2Fposts%2Fsome-proofs%2F&amp;src=sdkpreparse\" \n class=\"fb-xfbml-parse-ignore\"&gt;Share&lt;/a&gt;&lt;/div&gt;\n\n&lt;script src=\"https://platform.linkedin.com/in.js\" type=\"text/javascript\"&gt;lang: en_US&lt;/script&gt;\n&lt;script type=\"IN/Share\" data-url=\"https://mrislambd.github.io/posts/some-proofs/\"&gt;&lt;/script&gt; \n \n&lt;a href=\"https://twitter.com/share?ref_src=twsrc%5Etfw\" class=\"twitter-share-button\" \n data-url=\"https://mrislambd.github.io/posts/some-proofs/\" data-show-count=\"true\"&gt;Tweet&lt;/a&gt;\n&lt;script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"&gt;&lt;/script&gt;\n&lt;/div&gt;\n\n&lt;div class=\"fb-comments\" data-href=\"https://mrislambd.github.io/posts/some-proofs/\"\n data-width=\"\" data-numposts=\"5\"&gt;&lt;/div&gt;\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "talks/2023-10-05-st-op.html",
    "href": "talks/2023-10-05-st-op.html",
    "title": "Decentralized Stochastic Gradient Langevin Dynamics andHamiltonian Monte Carlo",
    "section": "",
    "text": "This presentation is based on the paper Decentralized Stochastic Gradient Langevin Dynamics andHamiltonian Monte Carlo by Dr. Lingjiong Zhu\nA copy of the presentation can be found here\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "talks/2020-04-26-project.html",
    "href": "talks/2020-04-26-project.html",
    "title": "Sensitivity analysis for Monte Carlo and Quasi Monte Carlo option pricing",
    "section": "",
    "text": "A copy of the presentation can be found  here \n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "publication/paper2.html",
    "href": "publication/paper2.html",
    "title": "GJR-GARCH Volatility Modeling under NIG and ANN for Predicting Top Cryptocurrencies",
    "section": "",
    "text": "Cryptocurrencies are currently traded worldwide, with hundreds of different currencies in existence and even more on the way. This study implements some statistical and machine learning approaches for cryptocurrency investments. First, we implement GJR-GARCH over the GARCH model to estimate the volatility of ten popular cryptocurrencies based on market capitalization: Bitcoin, Bitcoin Cash, Bitcoin SV, Chainlink, EOS, Ethereum, Litecoin, TETHER, Tezos, and XRP. Then, we use Monte Carlo simulations to generate the conditional variance of the cryptocurrencies using the GJR-GARCH model, and calculate the value at risk (VaR) of the simulations. We also estimate the tail-risk using VaR backtesting. Finally, we use an artificial neural network (ANN) for predicting the prices of the ten cryptocurrencies. The graphical analysis and mean square errors (MSEs) from the ANN models confirmed that the predicted prices are close to the market prices. For some cryptocurrencies, the ANN models perform better than traditional ARIMA models.\n\nDownload the paper from here\n\n\n\n\n\n Back to topCitationBibTeX citation:@online{mostafa;_pritam_saha;_mohammad_rafiqul_islam;_nguyet_nguyen2021,\n  author = {Mostafa; Pritam Saha; Mohammad Rafiqul Islam; Nguyet Nguyen,\n    Fahad},\n  title = {GJR-GARCH {Volatility} {Modeling} Under {NIG} and {ANN} for\n    {Predicting} {Top} {Cryptocurrencies}},\n  date = {2021-09-03},\n  url = {https://mrislambd.github.io/publication/paper2.html},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nMostafa; Pritam Saha; Mohammad Rafiqul Islam; Nguyet Nguyen, Fahad.\n2021. “GJR-GARCH Volatility Modeling Under NIG and ANN for\nPredicting Top Cryptocurrencies.” September 3, 2021. https://mrislambd.github.io/publication/paper2.html."
  },
  {
    "objectID": "posts/matmul/index.html",
    "href": "posts/matmul/index.html",
    "title": "Matrix multiplication: Let’s make it less expensive!",
    "section": "",
    "text": "Have you ever wondered why your code takes forever to run? Sometimes a simple code may take significant time because of an inefficient implementation approach. Let’s take a simple example of matrix multiplication, and explore the time and space complexity, specifically focusing on multiplying matrices where one of the matrices is formed as an outer product of a vector with itself.\nMatrix multiplication is a fundamental operation in many areas such as computer graphics, machine learning, and scientific computing. Given two matrices \\(\\mathbf{A}\\) and \\(\\mathbf{B}\\), the product \\(\\mathbf{AB}\\) or \\(\\mathbf{BA}\\) is a new matrix where each element is computed as the dot product of the corresponding row of \\(\\mathbf{A}\\) and the column of \\(\\mathbf{B}\\) or the other way around.\nConsider the scenario where \\(\\mathbf{A}\\) is an outer product of a column vector \\(\\mathbf{a}\\) with itself, i.e.,\n\\[\\begin{align*}\n\\mathbf{A}=\\mathbf{a} \\mathbf{a}^T&=\\begin{pmatrix}a_1\\\\a_2\\\\\\vdots \\\\a_n\\end{pmatrix}\\begin{pmatrix}a_1&a_2&\\cdots &a_n\\end{pmatrix}\\\\\n&=\\begin{pmatrix}\na_1a_1 & a_1a_2& \\cdots &a_1a_n\\\\\na_2a_1& a_2a_2&\\cdots &a_2a_n\\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\na_na_1 & a_na_2 &\\cdots& a_na_n\\end{pmatrix}\\\\\n\\end{align*}\n\\]\nNow simply, if \\(\\mathbf{B}\\) is another \\(n\\times n\\) matrix, then\n\\[\n\\begin{align*}\n\\mathbf{BA}&=\\begin{pmatrix}\nb_{11} & b_{12} & \\cdots & b_{1n}\\\\\nb_{21} & b_{22} & \\cdots & b_{2n}\\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\nb_{n1} & b_{n2} & \\cdots & b_{nn}\\\\\n\\end{pmatrix}\\begin{pmatrix}\na_1a_1 & a_1a_2& \\cdots &a_1a_n\\\\\na_2a_1& a_2a_2&\\cdots &a_2a_n\\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\na_na_1 & a_na_2 &\\cdots& a_na_n\\end{pmatrix}\n\\end{align*}\n\\]\nLet’s analyze the complexity of this matrix matrix multiplication.\nWorst Case: The worst case scenario would be performing the multiplication naively without exploiting the rank-1 structure. How? When we compute any element in the resultant matrix \\(\\mathbf{BA}\\) or \\(\\mathbf{AB}\\) we precisely perform \\(n\\) multiplication and there are total \\(n^2\\) elements to compute for a matrix of \\(n\\times n\\). This would result in the standard matrix multiplication time complexity of \\(O(n^3)\\).\n\\[\n\\begin{align*}\n\\mathbf{BA}&=\\begin{pmatrix}\nb_{11}a_1a_1+\\cdots+b_{1n}a_na_1& b_{11}a_1a_2+\\cdots+b_{1n}a_na_2 &\\cdots &\nb_{11}a_1a_n+\\cdots+b_{1n}a_na_n\\\\\nb_{21}a_1a_1+\\cdots+b_{2n}a_na_1&b_{21}a_1a_2+\\cdots+b_{2n}a_na_2 &\\cdots &\nb_{21}a_1a_n+\\cdots+b_{2n}a_na_n\\\\\n\\vdots & \\vdots &\\ddots & \\vdots\\\\\nb_{n1}a_1a_1+\\cdots+b_{nn}a_na_1&b_{n1}a_1a_2+\\cdots+b_{nn}a_na_2 &\\cdots &\nb_{n1}a_1a_n+\\cdots+b_{nn}a_na_n\\end{pmatrix}\n\\end{align*}\n\\]\nBest Case: The best case scenario in terms of time complexity occurs when we exploit the structure of \\(\\mathbf{A}\\). Since \\(\\mathbf{A}\\) is a rank-1 matrix, we can simplify the multiplication: \\[\n\\begin{align*}\n\\mathbf{BA}&=\\mathbf{B}\\begin{pmatrix}\na_1a_1 & a_1a_2& \\cdots &a_1a_n\\\\\na_2a_1& a_2a_2&\\cdots &a_2a_n\\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\na_na_1 & a_na_2 &\\cdots& a_na_n\\end{pmatrix}\\\\\n&\\\\\n&=\\mathbf{B}\\begin{pmatrix}a_1 \\mathbf{a} & a_2 \\mathbf{a} &\\cdots a_n \\mathbf{a}\\end{pmatrix}\\\\\n&=\\begin{pmatrix}a_1 \\mathbf{B}\\mathbf{a} & a_2 \\mathbf{B}\\mathbf{a} &\\cdots a_n \\mathbf{B}\\mathbf{a}\\end{pmatrix}\\\\\n&= (\\mathbf{Ba}) a^T\n\\end{align*}\n\\]\nWe break this algorithm in to two steps.\nStep 1: Since \\(\\mathbf{B}\\) is a matrix of \\(n\\times n\\) and \\(\\mathbf{a}\\) is a matrix of \\(n\\times 1\\), therefore \\(\\mathbf{Ba}\\) is a matrix of size \\(n\\times 1\\) or just a vector of size \\(n\\).\n\\[\n\\begin{align*}\n\\mathbf{Ba}&=\\begin{pmatrix}\nb_{11} & b_{12} & \\cdots & b_{1n}\\\\\nb_{21} & b_{22} & \\cdots & b_{2n}\\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\nb_{n1} & b_{n2} & \\cdots & b_{nn}\\\\\n\\end{pmatrix}\\begin{pmatrix}a_1\\\\a_2\\\\ \\vdots \\\\a_n \\end{pmatrix}\\\\\n&\\\\\n&=\\begin{pmatrix}\n    b_{11}a_1+b_{12}a_2+\\cdots b_{1n}a_n\\\\\n    b_{21}a_1+b_{22}a_2+\\cdots b_{2n}a_n\\\\\n    \\vdots\\\\\n    b_{n1}a_1+b_{n2}a_2+\\cdots b_{nn}a_n\\\\\n\\end{pmatrix}\n\\end{align*}\n\\] The matrix \\(\\mathbf{Ba}\\) contains \\(n\\) elements where each element takes \\(n\\) multiplications. Thus, computing \\(\\mathbf{Ba}\\) takes \\(O(n^2)\\) time.\nStep 2: Next, we compute \\((\\mathbf{Ba})\\mathbf{a}^T\\).\n\\[\n\\begin{align*}\n(\\mathbf{Ba})\\mathbf{a}^T&=\\begin{pmatrix}ba_1\\\\ ba_2\\\\ \\vdots\\\\ ba_n \\end{pmatrix}\n\\begin{pmatrix}a_{1}& a_{2}& \\cdots a_{n} \\end{pmatrix}\\\\\n&\\\\\n&=\\begin{pmatrix}\n(ba_1)a_1 & (ba_1)a_2 &\\cdots &(ba_1)a_n\\\\\n(ba_2)a_1 & (ba_2)a_2 &\\cdots &(ba_2)a_n\\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\n(ba_n)a_1 & (ba_n)a_2 &\\cdots &(ba_n)a_n\\\\\n\\end{pmatrix}\n\\end{align*}\n\\] Forming the outer product of \\(\\mathbf{Ba}\\) and \\(\\mathbf{a}^T\\) also takes \\(O(n^2)\\) time. Thus, the best case time complexity is \\(O(n^2)\\).\nWell, how about the other way around? What’s the optimal strategy for \\(\\mathbf{AB}\\)? We can reach similar results in the following way \\[\n\\begin{align*}\n\\mathbf{AB}&=(\\mathbf{a} \\mathbf{a}^T) \\mathbf{B} = \\mathbf{a} (\\mathbf{a}^T \\mathbf{B})\n\\end{align*}\n\\]\nHere, \\(\\mathbf{a}^T \\mathbf{B}\\) is a row vector of size \\(n\\). Computing \\(\\mathbf{a}^T \\mathbf{B}\\) takes \\(O(n^2)\\) time. Then, multiplying the column vector \\(\\mathbf{a}\\) by the resulting row vector forms an \\(n \\times n\\) matrix, also in \\(O(n^2)\\) time. Thus, the best case time complexity is \\(O(n^2)\\). Note, that \\(\\mathbf{AB}\\ne \\mathbf{BA}\\).\nComparison: So, what’s the big difference? There is a significant difference in two algorithms. In the first algorithm the time complexity is \\(O(n^3)\\) where as in the second algorithm the time complexity is \\(O(n^2)+O(n^2)\\) or \\(2O(n^2)\\) or just \\(C\\hspace{1mm} O(n^2)\\). For example, if \\(n=500\\) then the first algorithm requires 125 million multiplications and the second one just takes 500,000 multiplications which is 250 times faster.\nUnderstanding the structure of the matrices involved in multiplication can significantly optimize the performance of our code. By exploiting the rank-1 structure of the outer product matrix \\(\\mathbf{a} = \\mathbf{a} \\mathbf{a}^T\\), we can reduce the time complexity from \\(O(n^3)\\) to \\(O(n^2)\\) in the best case scenario. This optimization can lead to considerable performance improvements, especially for large matrices.\nSpace Complexity: Regardless of the case, the space complexity remains \\(O(n^2)\\) since we need to store the resulting \\(n \\times n\\) matrix \\(\\mathbf{BA}\\).\nPython Code:"
  },
  {
    "objectID": "posts/matmul/index.html#output",
    "href": "posts/matmul/index.html#output",
    "title": "Matrix multiplication: Let’s make it less expensive!",
    "section": "Output",
    "text": "Output\nNaive Multiplication Time: 27.198208 seconds\nOptimized Multiplication Time: 0.001841 seconds\nWhat about when \\(\\mathbf{A}\\) is not given as \\(\\mathbf{A}=\\mathbf{aa}^T\\) (i.e., it’s not a rank-1 matrix)? We simply cannot exploit the same optimization based on the outer product. In this case, we have to use the general matrix multiplication approach, which typically has a time complexity of \\(O(n^3)\\) for naive multiplication. However, there are optimized algorithms that can reduce the time complexity:\n\nStrassen’s Algorithm: Reduces the time complexity to approximately \\(O(n^{2.81})\\)\n\nCoppersmith-Winograd Algorithm: Further reduces the time complexity to approximately \\(O(n^{2.376})\\)\n\nParallel Algorithms: Use parallel computing techniques to perform matrix multiplication more efficiently.\n\nMay be some other day we can talk about these algorithms.\n\n\n\n\n\n\n\n\nShare on\n\n\nShare\n\n\n\nTweet\n\n\n\n\n\nYou may also like"
  },
  {
    "objectID": "posts/social-share/index.html",
    "href": "posts/social-share/index.html",
    "title": "How to generate social share buttons",
    "section": "",
    "text": "If you want to share any blog posts on social media, you can have a share button at the bottom of each post so that the reader can easily share this on their preferred social media such as Facebook, LinkedIn, and X. Here I am showing only three but can be added more.\n\n\n\n# Library you need\nimport urllib.parse\n\n# Define the function to parse facebook sharable link\ndef fblink(link):\n    base_url = \"https://www.facebook.com/sharer/sharer.php\"\n    encoded_url = urllib.parse.quote(link, safe='')\n    full_url= f\"{base_url}?u={encoded_url}&amp;src=sdkpreparse\"\n    return full_url  \n\n# Suppose this is the link you want to share. Replace with your own link  \nlink=\"https://mrislambd.github.io/posts/social-share/\"\n\n# Then you can use this template\nprint('&lt;div id=\"fb-root\"&gt;&lt;/div&gt;')\nprint('&lt;script async defer crossorigin=\"anonymous\"\\n src=\"https://connect.facebook.net/en_US/sdk.js#xfbml=1&version=v20.0\"&gt;&lt;/script&gt;')\nprint(' ')\nprint('&lt;div class=\"share-buttons\"&gt;')\nprint('&lt;div class=\"fb-share-button\" data-href=\"{}\"'.format(link))\nprint('data-layout=\"button_count\" data-size=\"small\"&gt;&lt;a target=\"_blank\" \\n href=\"{}\" \\n class=\"fb-xfbml-parse-ignore\"&gt;Share&lt;/a&gt;&lt;/div&gt;'.format(fblink(link)))\nprint('')\nprint('&lt;script src=\"https://platform.linkedin.com/in.js\" type=\"text/javascript\"&gt;lang: en_US&lt;/script&gt;')\nprint('&lt;script type=\"IN/Share\" data-url=\"{}\"&gt;&lt;/script&gt; '.format(link)) \nprint(' ')\nprint('&lt;a href=\"https://twitter.com/share?ref_src=twsrc%5Etfw\" class=\"twitter-share-button\" \\n data-url=\"{}\" data-show-count=\"true\"&gt;Tweet&lt;/a&gt;'.format(link))\nprint('&lt;script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"&gt;&lt;/script&gt;')\nprint('&lt;/div&gt;')\nprint('')\nprint('&lt;div class=\"fb-comments\" data-href=\"{}\"\\n data-width=\"\" data-numposts=\"5\"&gt;&lt;/div&gt;'.format(link)) \n# Then you can directly post the following output at the bottom of your page \n\n&lt;div id=\"fb-root\"&gt;&lt;/div&gt;\n&lt;script async defer crossorigin=\"anonymous\"\n src=\"https://connect.facebook.net/en_US/sdk.js#xfbml=1&version=v20.0\"&gt;&lt;/script&gt;\n \n&lt;div class=\"share-buttons\"&gt;\n&lt;div class=\"fb-share-button\" data-href=\"https://mrislambd.github.io/posts/social-share/\"\ndata-layout=\"button_count\" data-size=\"small\"&gt;&lt;a target=\"_blank\" \n href=\"https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fmrislambd.github.io%2Fposts%2Fsocial-share%2F&amp;src=sdkpreparse\" \n class=\"fb-xfbml-parse-ignore\"&gt;Share&lt;/a&gt;&lt;/div&gt;\n\n&lt;script src=\"https://platform.linkedin.com/in.js\" type=\"text/javascript\"&gt;lang: en_US&lt;/script&gt;\n&lt;script type=\"IN/Share\" data-url=\"https://mrislambd.github.io/posts/social-share/\"&gt;&lt;/script&gt; \n \n&lt;a href=\"https://twitter.com/share?ref_src=twsrc%5Etfw\" class=\"twitter-share-button\" \n data-url=\"https://mrislambd.github.io/posts/social-share/\" data-show-count=\"true\"&gt;Tweet&lt;/a&gt;\n&lt;script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"&gt;&lt;/script&gt;\n&lt;/div&gt;\n\n&lt;div class=\"fb-comments\" data-href=\"https://mrislambd.github.io/posts/social-share/\"\n data-width=\"\" data-numposts=\"5\"&gt;&lt;/div&gt;\n\n\nShare on\n\n\n\n\n\n\nShare\n\n\n\nTweet\n\n\n\n\n\nYou may also like\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMatrix multiplication: Let’s make it less expensive!\n\n\n6 min\n\n\n\nRafiq Islam\n\n\nMonday, July 1, 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nModeling viral disease\n\n\n3 min\n\n\n\nRafiq Islam\n\n\nTuesday, February 23, 2021\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nUnderstanding Stochastic Gradient Descent Using Simple Linear Regression\n\n\n5 min\n\n\n\nRafiq Islam\n\n\nSaturday, May 25, 2024\n\n\n\n\n\n\n\n\nNo matching items\n\n Back to topCitationBibTeX citation:@online{islam2024,\n  author = {Islam, Rafiq},\n  title = {How to Generate Social Share Buttons},\n  date = {2024-07-17},\n  url = {https://mrislambd.github.io/posts/social-share/},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nIslam, Rafiq. 2024. “How to Generate Social Share Buttons.”\nJuly 17, 2024. https://mrislambd.github.io/posts/social-share/."
  },
  {
    "objectID": "posts/mathbiology/index.html",
    "href": "posts/mathbiology/index.html",
    "title": "Modeling viral disease",
    "section": "",
    "text": "Consider the spreading of a highly communicable disease on an isolated island with population size \\(N\\). A portion of the population travels abroad and returns to the island infected with the disease. You would like to predict the number of people \\(X\\) who will have been infected by some time \\(t\\). Consider the following model, where \\(k &gt; 0\\) is constant:\n\\[\\begin{equation*}\n  \\frac{dX}{dt}=k\\textcolor{red}{X}(N-X)\n\\end{equation*}\\]\n\nList two major assumptions implicit in the preceding model. How reasonable are your assumptions?\nAnswer: Here are two major assumptions:\n\n\n\nFixed population \\(\\implies\\) all infected. We assume the population size remain unchanged that is no one gets in the island or no one gets out of the island. This will lead everyone affected by the disease eventually.\nNo immediate cure or vaccination. We also assume that there is no immediate hard immunity build up among the population or invention of vaccination.\n\n\nGraph \\(\\frac{dX}{dt}\\) versus \\(X\\)\n\n\n\n\nPhoto\n\n\n\nGraph \\(X\\) versus \\(t\\) if the initial number of infections is \\(X_1 &lt; \\frac{N}{2}\\). Graph \\(X\\) versus \\(t\\) if the initial number of infections is \\(X_2 &gt;\\frac{N}{2}\\).\nAnswer: For equilibrium of the model\n\n\\[\\begin{align*}\n  f(X)&=kX(N-X)=0\\\\\n  \\implies kX&=0 & N-X=0\\\\\n  \\implies X=&0  & X=N\n\\end{align*}\\] For the stability analysis:\n\\[\\begin{align*}\nf(X)&=(kN)X-kX^2 & \\implies f'(X)=kN-2kX\n\\end{align*}\\]\nNow, \\(f'(0)=kN&gt;0\\) therefore, \\(X=0\\) is an unstable equilibrium. And \\(f'(N)=kN-2kN=-kN&lt;0\\) since \\(k, N&gt;0\\). So, \\(X=N\\) is a stable equilibrium.\n\n\n\nequilibrium\n\n\nIf the initial infection \\(X_1&lt;\\frac{N}{2}\\) it might decrease and reach to 0 but that is not a stable equilibrium. So eventually it will hit \\(N\\).\n\nSolve the model given earlier for \\(X\\) as a function of \\(t\\).\nAnswer: Solving the ODE we have\n\n\\[\\begin{align*}\n  \\frac{dX}{dt}&=kX(N-X)\\\\\n  \\text{Since}\\hspace{2mm} X&&gt;0\\\\\n  \\frac{dX}{X(N-X)}&=kdt\\\\\n  \\implies \\int \\frac{dX}{X(N-X)}&=\\int kdt\\\\\n  \\implies \\frac{1}{N}\\int \\left(\\frac{1}{X}+\\frac{1}{N-X}\\right)dX&= \\int kdt\\\\\n  \\implies \\frac{1}{N} \\ln\\left(\\frac{X}{N-X}\\right)&=kt+c\\\\\n  \\implies \\ln\\left(\\frac{X}{N-X}\\right)&=Nkt+Nc\\\\\n  \\implies \\frac{X}{N-X}&=e^{Nkt+Nc}\\\\\n  \\implies X&=Ne^{Nkt+Nc}-Xe^{Nkt+Nc}\\\\\n  \\implies X\\left(1+e^{Nkt+Nc}\\right)&=Ne^{Nkt+Nc}\\\\\n  \\implies X(t)&=\\frac{Ne^{Nkt+Nc}}{1+e^{Nkt+Nc}}\\\\\n  \\implies X(t)&=\\frac{N}{1+e^{-(Nkt+Nc)}}\n\\end{align*}\\]\n\nFrom part (d), find the limit of \\(X\\) as \\(t\\) approaches infinity.\nAnswer:\n\n\\[\\begin{align*}\n\\lim_{t\\longrightarrow \\infty} X(t)&=\\lim_{t\\longrightarrow \\infty} \\frac{N}{1+e^{-(Nkt+Nc)}}=N\n\\end{align*}\\]\n\nConsider an island with a population of \\(5000\\). At various times during the epidemic the number of people infected was recorded as follows:\n\n\n\n\n\\(t\\) (days)\n2\n6\n\n\n\n\n\\(X\\) (People infected)\n\\(1887\\)\n\\(4087\\)\n\n\n\\(\\ln{\\left(\\frac{X}{N-X}\\right)}\\)\n\\(-0.5\\)\n\\(1.5\\)\n\n\n\nDo the collected data support the given model?\nAnswer: If we look at part (d) we have\n\\[\\begin{align*}\n\\ln\\left(\\frac{X}{N-X}\\right)&=Nkt+Nc & \\text(And),\\\\\nX(t)&=\\frac{N}{1+e^{-(Nkt+Nc)}}\n\\end{align*}\\]\nSo we get if \\(2Nk+Nc=-0.5\\) then \\(X(2)=\\frac{5000}{1+e^{0.5}}=1887.703\\), if \\(6Nk+Nc=1.5\\) then \\(X(6)=\\frac{5000}{e^{-1.5}}=4087.87\\), and if \\(10Nk+Nc=3.5\\) then \\(X(10)=\\frac{5000}{e^{-3.5}}=4853.44\\)\nTherefore, the collected data supports the model.\n\nUse the results in part (f) to estimate the constants in the model, and predict the number of people who will be infected by \\(t = 12\\) days.\nAnswer: We have\n\n\\[\\begin{align*}\n2Nk+Nc&=-0.5\\\\\n6Nk+Nc&=1.5\n\\end{align*}\\]\nSolving the above system we have \\(k=\\frac{1}{2N}\\) and \\(c=\\frac{-1.5}{N}\\). If we substitute these values in the solution we got in part (d) we have\n\\[\\begin{align*}\n  X(t)&=\\frac{N}{1+e^{-\\left(\\frac{t}{2}-1.5\\right)}}\n\\end{align*}\\]\nSo, \\(X(12)\\approx 4945\\)\n\n\n\n\n\n\n\n\nShare on\n\n\nShare\n\n\n\nTweet\n\n\n\n\n\nYou may also like\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHow to generate social share buttons\n\n\n2 min\n\n\n\nRafiq Islam\n\n\nWednesday, July 17, 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMatrix multiplication: Let’s make it less expensive!\n\n\n6 min\n\n\n\nRafiq Islam\n\n\nMonday, July 1, 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nUnderstanding Stochastic Gradient Descent Using Simple Linear Regression\n\n\n5 min\n\n\n\nRafiq Islam\n\n\nSaturday, May 25, 2024\n\n\n\n\n\n\n\n\nNo matching items\n\n Back to topCitationBibTeX citation:@online{islam2021,\n  author = {Islam, Rafiq},\n  title = {Modeling Viral Disease},\n  date = {2021-02-23},\n  url = {https://mrislambd.github.io/posts/mathbiology/},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nIslam, Rafiq. 2021. “Modeling Viral Disease.” February 23,\n2021. https://mrislambd.github.io/posts/mathbiology/."
  },
  {
    "objectID": "teaching.html",
    "href": "teaching.html",
    "title": "Teaching",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\nTitle\n\n\nDescription\n\n\n\n\n\n\nSpring 2024: MAP4170 Introduction to Actuarial Mathematics\n\n\n\n\n\n\n\nFall 2023: MAP4170 Introduction to Actuarial Mathematics\n\n\n\n\n\n\n\nSpring 2023: MAC1140 PreCalculus Algebra\n\n\n\n\n\n\n\nFall 2022: MAC2311 Calculus and Analytic Geometry I\n\n\n\n\n\n\n\nFall 2021 and Spring 2022: PreCalculus and Algebra\n\n\n\n\n\n\n\nFall 2018 to Spring 2020: College Algebra, Trigonometry\n\n\n\n\n\n\n\n\nNo matching items\n\n Back to top"
  },
  {
    "objectID": "research.html",
    "href": "research.html",
    "title": "",
    "section": "",
    "text": "Code\nCurrently I am working under the supervision of professor Lingjiong Zhu. My ongoing research project is on the topic “EXTRA decentralized stochastic gradient Langevin dynamics”."
  },
  {
    "objectID": "research.html#research-interest",
    "href": "research.html#research-interest",
    "title": "",
    "section": "Research Interest",
    "text": "Research Interest\n\nTheoretical Machine Learning: Centralized and Decentralized Stochastic Gradient Descent (SGD);Algorithmic Stability in SGD; Differential Privacy in machine learning algorithms\nApplied Data Science\nFinancial Mathematics"
  },
  {
    "objectID": "research.html#publications",
    "href": "research.html#publications",
    "title": "",
    "section": "Publications",
    "text": "Publications\n\nYou can also find my articles on my Google Scholar profile.\n\n\nGJR-GARCH Volatility Modeling under NIG and ANN for Predicting Top Cryptocurrencies \nMostafa, F; Saha, P; Islam, Mohammad R.; Nguyen, N. (2020) “Comparison of financial models for stock price prediction.” Journal of Risk and Financial Management.\nComparison of Financial Models for Stock Price Prediction \nIslam, Mohammad R.; Nguyen, N. (2020) “Comparison of financial models for stock price prediction.” Journal of Risk and Financial Management."
  },
  {
    "objectID": "research.html#course-projects",
    "href": "research.html#course-projects",
    "title": "",
    "section": "Course Projects",
    "text": "Course Projects\n\nOption pricing techniques: A performance-based comparative study of the randomized quasi-Monte Carlo method and Fourier cosine method\nAdvisor: Prof. Giray Ökten\n\nPricing financial derivatives such as options with desired accuracy can be hard due to the nature of the functions and complicated integrals required by the pricing techniques. In this paper we investigate the pricing methodology of the European style options using two advanced numerical methods, namely, Quasi-Monte Carlo and Fourier Cosine (COS). For the RQMC method, we use the random-start Halton sequence. We use the Black-Scholes-Merton model to measure the pricing quality of both of the methods. For the numerical results we compute the option price of the call option and we found a few reasons to prefer the RQMC method over the COS method to approximate the European style options.\n\nThe Relationship Between Forced Sexual Activities And Suicidal Attempts Of The Victims\nAdvisor: Dr. Andy Chang\n\nIn project, we apply data-analytic methods to further explore the relationship between forced sexual activities and suicidal behavior among adolescents in the United States. Our findings build on existing literature that explores this relationship. The sample of the study was taken from the Youth Risk Behavior Surveillance System survey 2017. We used a chi-squared test to find the association of forced sexual activities and suicidal behavior, and we found a strong association. Then we used bi-variate logistic regression analysis to ascertain the association of race, age, sex, and education with suicidal attempts after experiencing forced sexual activity (sexual assault). The results of the following paper provide greater insight into the relationship between forced sexual activities and suicide attempts by the adolescents.\n\nStudy of Runge-Kutta Method of Higher orders and its Applications\nAdvisor: Dr. Md. Abdus Samad \n\nThis project is concerned with the study on Runge-Kutta method to apply on different order of differential equation and solve different types of problem such as initial value problem and boundary value problem in ordinary differential equation. At first we discuss about the definition and generation of differential equation specially based on partial differential equation and then definition of Runge-kutta method and the derivation of midpoint method and the formula of Runge-Kutta metod of fourth order and sixth order. We also write FORTRAN 90/95 program for different order of Runge-Kutta methods. We have solved some examples of fourth order R-K method and sixth order R-K method to get the application of R-K method. We also compared the solution of R-K method with exact solution for different step sizes. Then we have given simultaneous first order differential equation and second order differential equation and then solved them by fourth order Runge-Kutta method. At last we have discussed the boundary value problem which we have solved by fourth and sixth order R-K method. After that we have written the algorithm of shooting method and showed computer results with the difference between two answer along with percentages of error."
  },
  {
    "objectID": "research.html#talks-and-presentations",
    "href": "research.html#talks-and-presentations",
    "title": "",
    "section": "Talks and Presentations",
    "text": "Talks and Presentations"
  },
  {
    "objectID": "posts/sgd-linreg/index.html",
    "href": "posts/sgd-linreg/index.html",
    "title": "Understanding Stochastic Gradient Descent Using Simple Linear Regression",
    "section": "",
    "text": "Linear regression is a fundamental algorithm in machine learning used for predicting a continuous dependent variable based on one or more independent variables. The objective is to find the best-fit line that minimizes the difference between the predicted and actual values.\nA simple linear regression in multiple predictors/input variables/features/independent variables/ explanatory variables/regressors/ covariates (many names) often takes the form\n\\[y=f(\\mathbf{x})+\\epsilon =\\mathbf{\\beta}\\mathbf{x}+\\epsilon\\]\nwhere \\(\\mathbf{\\beta} \\in \\mathbb{R}^d\\) are regression parameters or constant values that we aim to estimate and \\(\\epsilon \\sim \\mathcal{N}(0,1)\\) is a normally distributed error term independent of \\(x\\) or also called the white noise.\nFor simplicity let’s start with this toy example. Say, we have the data from a class of 10 students and their heights and weights are as follows:\nand this data looks like this:\nIn this case, the model:\n\\[y=f(x)+\\epsilon=\\beta_0+\\beta_1 x+\\epsilon\\]\nTherefore, in our model we need to estimate the parameters \\(\\beta_0,\\beta_1\\). The true relationship between the explanatory variables and the dependent variable is \\(y=f(x)\\). But our model is \\(y=f(x)+\\epsilon\\). Here, this \\(f(x)\\) is the working model with the data. In other words, \\(\\hat{y}=f(x)=\\hat{\\beta}_0+\\hat{\\beta}_1 x\\). Therefore, there should be some error in the model prediction which we are calling \\(\\epsilon=\\|y-\\hat{y}\\|\\) where \\(y\\) is the true value and \\(\\hat{y}\\) is the predicted value. This error term is normally distributed with mean 0 and variance 1. To get the best estimate of the parameters \\(\\beta_0,\\beta_1\\) we can minimize the error term as much as possible. So, we define the residual sum of squares (RSS) as:\n\\[\\begin{align}\nRSS &=\\epsilon_1^2+\\epsilon_2^2+\\cdots+\\epsilon_{10}^2\\\\\n&= \\sum_{i=1}^{10}(y_i-\\hat{\\beta}_0-\\hat{\\beta}_1 x_i)^2\\\\\n\\hat{\\mathcal{l}}(\\bar{\\beta})&=\\sum_{i=1}^{10}(y_i-\\hat{\\beta}_0-\\hat{\\beta}_1 x_i)^2\\\\\n\\end{align}\\]\nUsing multivariate calculus we see\n\\[\\begin{align}\n    \\frac{\\partial l}{\\partial \\beta_0}&=\\sum_{i=1}^{10} 2(y_i-\\hat{\\beta}_0-\\hat{\\beta}_1 x_i)(-1)\\\\\n    \\frac{\\partial l}{\\partial \\beta_1}&= \\sum_{i=1}^{10} 2(y_i-\\hat{\\beta}_0-\\hat{\\beta}_1 x_i)(-x_i)\n\\end{align}\\]\nSetting the partial derivatives to zero we solve for \\(\\hat{\\beta_0},\\hat{\\beta_1}\\) as follows\n\\[\\begin{align*}\n    \\frac{\\partial l}{\\partial \\beta_0}&=0\\\\\n    \\implies \\sum_{i=1}^{10} y_i-10 \\hat{\\beta_0}-\\hat{\\beta_1}\\left(\\sum_{i=1}^{10} x_i\\right)&=0\\\\\n    \\implies \\hat{\\beta_0}&=\\bar{y}-\\hat{\\beta_1}\\bar{x}\n\\end{align*}\\]\nand,\n\\[\\begin{align*}\n    \\frac{\\partial l}{\\partial \\beta_1}&=0\\\\\n    \\implies \\sum_{i=1}^{10} 2(y_i-\\hat{\\beta}_0-\\hat{\\beta}_1 x_i)(-x_i)&=0\\\\\n    \\implies \\sum_{i=1}^{10} (y_i-\\hat{\\beta}_0-\\hat{\\beta}_1 x_i)(x_i)&=0\\\\\n    \\implies \\sum_{i=1}^{10} x_iy_i-\\hat{\\beta_0}\\left(\\sum_{i=1}^{10} x_i\\right)-\\hat{\\beta_1}\\left(\\sum_{i=1}^{10} x_i^2\\right)&=0\\\\\n    \\implies \\sum_{i=1}^{10} x_iy_i-\\left(\\bar{y}-\\hat{\\beta_1}\\bar{x}\\right)\\left(\\sum_{i=1}^{10} x_i\\right)-\\hat{\\beta_1}\\left(\\sum_{i=1}^{10} x_i^2\\right)&=0\\\\\n    \\implies \\sum_{i=1}^{10} x_iy_i-\\bar{y}\\left(\\sum_{i=1}^{10} x_i\\right)+\\hat{\\beta_1}\\bar{x}\\left(\\sum_{i=1}^{10} x_i\\right)-\\hat{\\beta_1}\\left(\\sum_{i=1}^{10} x_i^2\\right)&=0\\\\\n    \\implies \\sum_{i=1}^{10} x_iy_i-\\bar{y}\\left(\\sum_{i=1}^{10} x_i\\right) -\\hat{\\beta_1}\\left(\\sum_{i=1}^{10}x_i^2-\\bar{x}\\sum_{i=1}^{10}x_i\\right)&=0\\\\\n    \\implies \\sum_{i=1}^{10} x_iy_i-\\bar{y}\\left(\\sum_{i=1}^{10} x_i\\right) -\\hat{\\beta_1}\\left(\\sum_{i=1}^{10}x_i^2-10\\bar{x}^2\\right)&=0\\\\\n    \\implies \\sum_{i=1}^{10} x_iy_i-\\bar{y}\\left(\\sum_{i=1}^{10} x_i\\right) -\\hat{\\beta_1}\\left(\\sum_{i=1}^{10}x_i^2-2\\times 10\\times \\bar{x}^2+10\\bar{x}^2\\right)&=0\\\\\n    \\implies \\hat{\\beta_1}&=\\frac{\\sum_{i=1}^{10} x_iy_i-10\\bar{x}\\bar{y}}{\\sum_{i=1}^{10}x_i^2-2\\times 10\\times \\bar{x}^2+10\\bar{x}^2}\\\\\n    \\implies \\hat{\\beta_1}&=\\frac{\\sum_{i=1}^{10} x_iy_i -10\\bar{x}\\bar{y}-10\\bar{x}\\bar{y}+10\\bar{x}\\bar{y}}{\\sum_{i=1}^{10}x_i^2-2\\bar{x}\\times 10\\times\\frac{1}{10}\\sum_{i=1}^{10}x_i +10\\bar{x}^2}\\\\\n    \\implies \\hat{\\beta_1}&=\\frac{\\sum_{i=1}^{10} x_iy_i-\\bar{y}\\left(\\sum_{i=1}^{10} x_i\\right)-\\bar{x}\\left(\\sum_{i=1}^{10} y_i\\right)+10\\bar{x}\\bar{y}}{\\sum_{i=1}^{10}(x_i-\\bar{x})^2}\\\\\n    \\implies \\hat{\\beta_1}&=\\frac{\\sum_{i=1}^{10}\\left(x_iy_i-x_i\\bar{y}-\\bar{x}y_i+\\bar{x}\\bar{y}\\right)}{\\sum_{i=1}^{10}(x_i-\\bar{x})^2}\\\\\n    \\implies \\hat{\\beta_1}&=\\frac{\\sum_{i=1}^{10}(x_i-\\bar{x})(y_i-\\bar{y})}{\\sum_{i=1}^{10}(x_i-\\bar{x})^2}\\\\\n\\end{align*}\\]\nTherefore, we have the following\n\\[\\begin{align*}\n     \\hat{\\beta_0}&=\\bar{y}-\\hat{\\beta_1}\\bar{x}\\\\\n     \\hat{\\beta_1}&=\\frac{\\sum_{i=1}^{10}(x_i-\\bar{x})(y_i-\\bar{y})}{\\sum_{i=1}^{10}(x_i-\\bar{x})^2}\n\\end{align*}\\]\nTo be continued in the next post…"
  },
  {
    "objectID": "posts/sgd-linreg/index.html#references",
    "href": "posts/sgd-linreg/index.html#references",
    "title": "Understanding Stochastic Gradient Descent Using Simple Linear Regression",
    "section": "References",
    "text": "References\n\n[1] James, Gareth, et al. An introduction to statistical learning: With applications in python. Springer Nature, 2023.\n\n\n\n\n\n\n\n\n\nShare on\n\n\nShare\n\n\n\nTweet\n\n\n\n\n\nYou may also like"
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome to my blog",
    "section": "",
    "text": "Here is a demo picture\n\n\n\n\n\n\n\n\n\nShare on\n\n\nShare\n\n\n\nTweet\n\n\n\n\n\nYou may also like\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHow to generate social share buttons\n\n\n2 min\n\n\n\nRafiq Islam\n\n\nWednesday, July 17, 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMatrix multiplication: Let’s make it less expensive!\n\n\n6 min\n\n\n\nRafiq Islam\n\n\nMonday, July 1, 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nModeling viral disease\n\n\n3 min\n\n\n\nRafiq Islam\n\n\nTuesday, February 23, 2021\n\n\n\n\n\n\n\n\nNo matching items\n\n Back to topCitationBibTeX citation:@online{islam2024,\n  author = {Islam, Rafiq},\n  title = {Welcome to My Blog},\n  date = {2024-07-12},\n  url = {https://mrislambd.github.io/posts/welcome/},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nIslam, Rafiq. 2024. “Welcome to My Blog.” July 12, 2024. https://mrislambd.github.io/posts/welcome/."
  },
  {
    "objectID": "publication/paper1.html",
    "href": "publication/paper1.html",
    "title": "Comparison of financial models for stock price prediction",
    "section": "",
    "text": "Time series analysis of daily stock data and building predictive models are complicated. This project presents a comparative study for stock price prediction using three different methods, namely autoregressive integrated moving average, artificial neural network, and stochastic process-geometric Brownian motion. Each of the methods is used to build predictive models using historical stock data collected from Yahoo Finance. Finally, output from each of the models is compared to the actual stock price. Empirical results show that the conventional statistical model and the stochastic model provide better approximation for next-day stock price prediction compared to the neural network model.\n\nDownload a pdf from here\n\n\n\n\n\n Back to topCitationBibTeX citation:@online{rafiqul_islam;_nguyet_nguen2020,\n  author = {Rafiqul Islam; Nguyet Nguen, Mohammad},\n  title = {Comparison of Financial Models for Stock Price Prediction},\n  date = {2020-08-14},\n  url = {https://mrislambd.github.io/publication/paper1.html},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nRafiqul Islam; Nguyet Nguen, Mohammad. 2020. “Comparison of\nFinancial Models for Stock Price Prediction.” August 14, 2020. https://mrislambd.github.io/publication/paper1.html."
  },
  {
    "objectID": "talks/2023-11-20-candi.html",
    "href": "talks/2023-11-20-candi.html",
    "title": "The Heavy-Tail Phenomenon in Decentralized Stochastic Gradient Descent",
    "section": "",
    "text": "Stochastic Gradient Descent (SGD) method is one of the most popular optimization techniques in machine learning, particularly in Deep Neural Network (DNN). The gradient noise in this method is often modeled by Gaussian or assumed to have finite variance. However, empirical evidence suggests that the gradient noises can be highly non-Gaussian and often exhibit heavy tails in nature. This heaviness has a direct relationship to the generalization performance of the algorithm.\n\n\nIn this candidacy paper we discuss materials from three papers where we first present the tail-index analysis in SGD that shows empirically that gradient noise can have heavy tails, and through metastability analysis, the heavy-tailed SGD validates the wide minima phenomenon. We then present the paper about the heavy-tail phenomenon in SGD and investigates the origins of the heavy tails. We show that the heaviness of the tail is related to the choice of stepsize, batch-size and other hyperparameters of the algorithm. Finally, we discuss the heavy-tail phenomenon in decentralized SGD. We conclude the candidacy paper by proposing a few future research directions.\n\nA copy of the presentation can be found here\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "",
    "section": "",
    "text": "Code\n\n\n\n\n\n\n\n\n\nWelcome to my website! I am currently a Ph.D. candidate in the Mathematics Department at Florida State University, where I also serve as a Graduate Teaching Assistant. My academic journey has been both diverse and enriching, spanning multiple institutions and fields of study.   Before joining FSU, I earned a second master’s degree in Mathematics from Youngstown State University in Ohio, USA. Prior to that, I completed my undergraduate degree in Mathematics at the University of Dhaka (DU), Bangladesh, followed by a one-year integrated master’s program in Applied Mathematics at the same institution.  After graduating from DU, I gained valuable industry experience by working for two years in the life insurance sector in Dhaka, Bangladesh. In pursuit of higher education and advanced research opportunities, I relocated to the United States in August 2018.  As a lifelong student and researcher of mathematics, my research interests are centered around Theoretical Machine Learning, Computational Finance, and various other areas of applied mathematics. I am passionate about advancing knowledge in these fields and contributing to their practical applications.\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "teaching/sp23.html",
    "href": "teaching/sp23.html",
    "title": "Spring 2023: MAC1140 PreCalculus Algebra",
    "section": "",
    "text": "PreCalculus and Algebra are one of the many important foundation math courses that open doors to many upper-level math and science courses. The topic of this course includes but not is limited to Complex Numbers, Piecewise Functions, Quadratic Functions, Polynomial Functions, Polynomial Division, Zeros of Polynomials, Rational Functions, Polynomial and Rational Inequalities, Inverse Functions, Exponential Functions, Logarithmic Functions, Properties of Logarithms, Exponential and Logarithmic Equations, and so on.  As an Instructor of Record for this course, I taught a class of 27 undergraduate students from different majors. I also proctor their lab classes where they take their quizzes and tests online and other application based lab activities.\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "teaching/fall23.html",
    "href": "teaching/fall23.html",
    "title": "Fall 2023: MAP4170 Introduction to Actuarial Mathematics",
    "section": "",
    "text": "Worked as a greader for this course.\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "teaching/f18-f21.html",
    "href": "teaching/f18-f21.html",
    "title": "Fall 2018 to Spring 2020: College Algebra, Trigonometry",
    "section": "",
    "text": "Responsible for the preparation and delivery of all lectures, making question paper for all exams, and the grading of tests and homework assignments for the following courses: - College Algebra, Fall 2018 - Trigonometry, Fall 2019 and Spring 2020\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "portfolio/dp-nlp/index.html",
    "href": "portfolio/dp-nlp/index.html",
    "title": "Disease diagnosis using classification and NLP",
    "section": "",
    "text": "Team Members\nRebecca Ceppas de Castro, Fulya Tastan, Philip Barron, Mohammad Rafiqul Islam, Nina Adhikari, Viraj Meruliya\nAutomatic Symptom Detection (ASD) and Automatic Diagnosis (AD) have seen several advances in recent years. Patients and medical professionals would benefit from tools that can aid in diagnosing diseases based on antecedents and presenting symptoms. The lack of quality healthcare in many parts of the world makes solving this problem a matter of utmost urgency. The aim of this project is to build a tool that can diagnose a disease based on a list of symptoms and contribute to our understanding of automatic diagnosis.\nProject Details\nSlides\nExecutive Summary\nGitHub Repo\n\n\n\n\n\n Back to topCitationBibTeX citation:@online{ceppas_de_castro,_fulya_tastan,_philip_barron,_mohammad_rafiqul_islam,_nina_adhikari,_viraj_meruliya_2024,\n  author = {Ceppas de Castro, Fulya Tastan, Philip Barron, Mohammad\n    Rafiqul Islam, Nina Adhikari, Viraj Meruliya , Rebecca},\n  title = {Disease Diagnosis Using Classification and {NLP}},\n  date = {2024-06-18},\n  url = {https://mrislambd.github.io/portfolio/dp-nlp/},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nCeppas de Castro, Fulya Tastan, Philip Barron, Mohammad Rafiqul Islam,\nNina Adhikari, Viraj Meruliya, Rebecca. 2024. “Disease Diagnosis\nUsing Classification and NLP.” June 18, 2024. https://mrislambd.github.io/portfolio/dp-nlp/."
  },
  {
    "objectID": "portfolio.html",
    "href": "portfolio.html",
    "title": "Portfolio",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n     \n  \n\n\n\n\n\n\n\n\nDisease diagnosis using classification and NLP\n\n\n1 min\n\n\n\nRebecca Ceppas de Castro, Fulya Tastan, Philip Barron, Mohammad Rafiqul Islam, Nina Adhikari, Viraj Meruliya\n\n\nTuesday, June 18, 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython Application Library: desgld packaging\n\n\n1 min\n\n\n\nRafiq Islam\n\n\nFriday, May 3, 2024\n\n\n\n\n\n\n\n\nNo matching items\n\n Back to top"
  },
  {
    "objectID": "posts/lu/index.html",
    "href": "posts/lu/index.html",
    "title": "LU Factorization of a Full rank Matrix using Fortran",
    "section": "",
    "text": "! This program factors a full rank matrix A into lower triangular (or trapezoidal) L and upper\n! triangular matrix U\nprogram LU_decompostion\n    implicit none\n    !############# #################List of main program variable##################################\n    integer::m,n\n    ! m is the # of rows of the matrix that we are working with\n    ! n is the # of columns that we are working with\n    doubleprecision, allocatable,dimension(:,:)::A,A1\n    ! A is the working matrix, A1 is the original matrix preserved to check correctness of factoring\n    integer,allocatable,dimension(:):: P,Q\n    ! P, Q are the row and column permutation vectors for partial and complete pivoting\n    character::method\n    !################################################################################################\n\n    ! ############################ Open an Input Data File###########################################\n    open(unit=1,file=&quot;data.txt&quot;)\n    ! ###############################################################################################\n\n    ! ################################# Read m, n of the matrix A ###################################\n    write(*,*)&quot;Input the number of rows of the matrix A, m&quot;\n    read(*,*) m\n    write(*,*)&quot;Input the number of columns of the matrix A, n&quot;\n    read(*,*)n\n    ! ##############################################################################################\n\n    ! ########################### Allocate Space ###################################################\n    allocate(A(m,n),A1(m,n),P(m),Q(n))\n    ! ##############################################################################################\n\n    ! Create the matrix A\n    print*,\n    call matrixA(m,n,A,A1)\n    print*,\n\n    !##################################### Choose the method #######################################\n    print*,&quot;What method you want to apply?&quot;\n    print*,&quot;For No Pivot input: N&quot;\n    print*, &quot;For Partial Pivot input: P&quot;\n    print*, &quot;For Complete Pivot input: C&quot;\n    read(*,*) method\n    !###############################################################################################\n\n    ! ############################### Execution of the methods #####################################\n    IF(method.eq.&quot;C&quot;.or.method.eq.&quot;c&quot;) THEN\n        print*, &quot;Complete Pivoting method has been selected&quot;\n        print*,\n        call completePivot(m,n,A,A1,P,Q)\n    ELSE IF(method.eq.&quot;P&quot;.or.method.eq.&quot;p&quot;) then\n        print*,&quot;Partial Pivoting method has been selected&quot;\n        print*,\n        call partialPivot(m,n,A,A1,P)\n    ELSE IF (method.eq.&quot;N&quot;.or.method.eq.&quot;n&quot;) then\n        print*, &quot;No Pivoting method has been selected&quot;\n        print*,\n        call noPivot(m,n,A,A1)\n    END IF\n\nend program\n\nsubroutine matrixA(m,n,A,A1)\n    integer,intent(in)::m,n\n    doubleprecision,dimension(m,n),intent(inout)::A,A1\n    integer::i\n    print*,\n    print*, &quot;This is the provided working matrix&quot;\n    print*\n    do i=1,m\n        read(1,*)A(i,:)\n        A1(i,:)=A(i,:)\n        print*,A(i,:)\n    end do\n    do i=1,n\n        IF(A(i,i)==0) then\n            print*,&quot;A 0 entry was found in the main diagonal.&quot;\n            print*, &quot;Therefore, pivoting is a must required&quot;\n        else if(A(i,i).lt.0.0001) then\n            print*, &quot;WARNING!! Diagonal Element is too small.&quot;\n        END IF\n    end do\nend subroutine\n\nsubroutine completePivot(m,n,A,A1,P,Q)\n    integer,intent(in)::m,n\n    doubleprecision,dimension(m,n),intent(inout)::A,A1\n    integer,dimension(m),intent(out)::P\n    integer,dimension(n),intent(out)::Q\n    integer::i,j,k,row,col\n    doubleprecision::temp\n\n    do k=1,n\n       call max_val(A,m,n,k,row,col)\n       do i=k,n\n            temp=A(i,col)\n            A(i,col)=A(i,k)\n            A(i,k)=temp\n        end do\n        Q(k)=col\n        do j=k,n\n            temp=A(k,j)\n            A(k,j)=A(row,j)\n            A(row,j)=temp\n        end do\n        P(k)=row\n\n        A(k+1:n,k)=A(k+1:n,k)/A(k,k)\n        do j=k+1,n\n            do i=k+1,n\n                A(i,j)=A(i,j)-A(i,k)*A(k,j)\n            end do\n        end do\n    end do\n    print*,\n    print*,&quot;------------------------------------------------------&quot;\n    print*,&quot;         Complete Pivot A=LU factorized array&quot;\n    print*,&quot;-------------------------------------------------------&quot;\n    print*,\n    do i=1,m\n        print*,A(i,:)\n    end do\n    print*,\n    print*, &quot;Permutation vector P=(&quot;,(P(i),i=1,m-1),&quot;)&quot;\n    print*,\n    print*, &quot;Permutation vector Q=(&quot;,(Q(i),i=1,n-1),&quot;)&quot;\n    print*,\n    print*,&quot;*******************************************************&quot;\n    print*,&quot;       Checking Correctness of the factorization&quot;\n    print*,&quot;*******************************************************&quot;\n    print*,\n    call CheckingCompletePivot(m,n,A,A1)\n\nend subroutine\n\n\nsubroutine CheckingCompletePivot(m,n,A,A1)\n    integer,intent(in)::m,n\n    doubleprecision,dimension(m,n),intent(inout)::A,A1\n    doubleprecision,dimension(n,n):: U\n    doubleprecision,dimension(m,n)::L,A2\n    integer::i,j\n\n    do i=1,m\n        do j=1,n\n            if(i.le.j)then\n                L(i,j)=0\n            else if (i.gt.j) then\n                L(i,j)=A(i,j)\n            end if\n            L(i,i)=1\n        end do\n    end do\n    do i=1,n\n        do j=1,n\n            if(i.le.j)then\n                U(i,j)=A(i,j)\n            else\n                U(i,j)=0.0\n            end if\n        end do\n    end do\n    print*,\n    print*, &#39;----------------------------------------------&#39;\n    print*,&quot;  Complete Pivot Upper triangular matrix U&quot;\n    print*, &#39;----------------------------------------------&#39;\n    print*,\n    do i=1,n\n        print*,U(i,:)\n    end do\n    print*,\n    print*, &#39;----------------------------------------------&#39;\n    print*,&quot;  Complete Pivot Lower triangular matrix L&quot;\n    print*, &#39;----------------------------------------------&#39;\n    print*,\n    do i=1,m\n        print*,L(i,:)\n    end do\n\n    A2=matmul(L,U)\n    print*,\n    print*, &#39;----------------------------------------------&#39;\n    print*,&quot;              Product of L U=&quot;\n    print*, &#39;----------------------------------------------&#39;\n    print*,\n    do i=1,m\n        print*,A2(i,:)\n    end do\n    print*,\n    print*, &#39;----------------------------------------------&#39;\n    print*, &quot;  Factoring Accuracy with the Frobenius-Norm&quot;\n    print*, &#39;----------------------------------------------&#39;\n    print*,\n    print*,&quot;Relative Error=&quot;,Frobenius(m,n,A1-A2)/Frobenius(m,n,A1)\n    print*\n    print*, &quot;Growth Factor=&quot;, Frobenius(m,n,matmul(abs(L),abs(U)))/Frobenius(m,n,A1)\n    print*,\n    print*, &#39;----------------------------------------------&#39;\n    print*, &quot;     Factoring Accuracy with the 1-Norm&quot;\n    print*, &#39;----------------------------------------------&#39;\n    print*,\n    print*,&quot;Relative Error=&quot;,norm1(m,n,A1-A2)/norm1(m,n,A1)\n    print*\n    print*, &quot;Growth Factor=&quot;, norm1(m,n,matmul(abs(L),abs(U)))/norm1(m,n,A1)\n    print*,\n    print*, &#39;----------------------------------------------&#39;\n    print*, &quot;     Factoring Accuracy with the Infinity-Norm&quot;\n    print*, &#39;----------------------------------------------&#39;\n    print*,\n    print*,&quot;Relative Error=&quot;,infinityNorm(m,n,A1-A2)/infinityNorm(m,n,A1)\n    print*\n    print*, &quot;Growth Factor=&quot;, infinityNorm(m,n,matmul(abs(L),abs(U)))/infinityNorm(m,n,A1)\nend subroutine\n\nsubroutine partialPivot(m,n,A,A1,P)\n    integer,intent(in)::m,n\n    doubleprecision,dimension(m,n),intent(inout)::A,A1\n    integer,dimension(m),intent(out)::P\n    integer::i,j,k,row\n    doubleprecision::temp\n\n    do k=1,n\n       call max_valP(A,m,n,k,row)\n        do j=k,n\n            temp=A(k,j)\n            A(k,j)=A(row,j)\n            A(row,j)=temp\n        end do\n        P(k)=row\n\n        A(k+1:n,k)=A(k+1:n,k)/A(k,k)\n        do j=k+1,n\n            do i=k+1,n\n                A(i,j)=A(i,j)-A(i,k)*A(k,j)\n            end do\n        end do\n    end do\n    print*,\n    print*,&quot;------------------------------------------------------&quot;\n    print*,&quot;          Partial Pivot A=LU factorized array&quot;\n    print*,&quot;-------------------------------------------------------&quot;\n    print*,\n    do i=1,m\n        print*,A(i,:)\n    end do\n    print*,\n    print*, &quot;Permutation vector P=(&quot;,(P(i),i=1,m-1),&quot;)&quot;\n    print*,\n    print*,&quot;*******************************************************&quot;\n    print*,&quot;       Checking Correctness of the factorization&quot;\n    print*,&quot;*******************************************************&quot;\n    print*,\n    call CheckingPartialPivot(m,n,A,A1)\nend subroutine\n\nsubroutine CheckingPartialPivot(m,n,A,A1)\n    integer,intent(in)::m,n\n    doubleprecision,dimension(m,n),intent(inout)::A,A1\n    doubleprecision,dimension(n,n):: U\n    doubleprecision,dimension(m,n)::L,A2\n    integer::i,j\n\n    do i=1,m\n        do j=1,n\n            if(i.le.j)then\n                L(i,j)=0\n            else if (i.gt.j) then\n                L(i,j)=A(i,j)\n            end if\n            L(i,i)=1\n        end do\n    end do\n    do i=1,n\n        do j=1,n\n            if(i.le.j)then\n                U(i,j)=A(i,j)\n            else\n                U(i,j)=0.0\n            end if\n        end do\n    end do\n    print*,\n    print*, &#39;----------------------------------------------&#39;\n    print*,&quot;  Partial Pivot Upper triangular matrix U&quot;\n    print*, &#39;----------------------------------------------&#39;\n    print*,\n    do i=1,n\n        print*,U(i,:)\n    end do\n    print*,\n    print*, &#39;----------------------------------------------&#39;\n    print*,&quot;  Partial Pivot Lower triangular matrix L&quot;\n    print*, &#39;----------------------------------------------&#39;\n    print*,\n    do i=1,m\n        print*,L(i,:)\n    end do\n\n    A2=matmul(L,U)\n    print*,\n    print*, &#39;----------------------------------------------&#39;\n    print*,&quot;       Partial Pivot Product of L U=&quot;\n    print*, &#39;----------------------------------------------&#39;\n    print*,\n    do i=1,m\n        print*,A2(i,:)\n    end do\n    print*,\n    print*, &#39;----------------------------------------------&#39;\n    print*, &quot; Factoring Accuracy with the Frobenius-Norm&quot;\n    print*, &#39;----------------------------------------------&#39;\n    print*,\n    print*,&quot;Relative Error=&quot;,Frobenius(m,n,A1-A2)/Frobenius(m,n,A1)\n    print*\n    print*, &quot;Growth Factor=&quot;, Frobenius(m,n,matmul(abs(L),abs(U)))/Frobenius(m,n,A1)\n    print*,\n    print*, &#39;----------------------------------------------&#39;\n    print*, &quot;     Factoring Accuracy with the 1-Norm&quot;\n    print*, &#39;----------------------------------------------&#39;\n    print*,\n    print*,&quot;Relative Error=&quot;,norm1(m,n,A1-A2)/norm1(m,n,A1)\n    print*\n    print*, &quot;Growth Factor=&quot;, norm1(m,n,matmul(abs(L),abs(U)))/norm1(m,n,A1)\n    print*,\n    print*, &#39;----------------------------------------------&#39;\n    print*, &quot;     Factoring Accuracy with the Infinity-Norm&quot;\n    print*, &#39;----------------------------------------------&#39;\n    print*,\n    print*,&quot;Relative Error=&quot;,infinityNorm(m,n,A1-A2)/infinityNorm(m,n,A1)\n    print*\n    print*, &quot;Growth Factor=&quot;, infinityNorm(m,n,matmul(abs(L),abs(U)))/infinityNorm(m,n,A1)\nend subroutine\n\nsubroutine noPivot(m,n,A,A1)\n    integer,intent(in)::m,n\n    doubleprecision,dimension(m,n),intent(inout)::A,A1\n    integer::i,j,k\n\n    do k=1,n\n        A(k+1:n,k)=A(k+1:n,k)/A(k,k)\n        do j=k+1,n\n            do i=k+1,n\n                A(i,j)=A(i,j)-A(i,k)*A(k,j)\n            end do\n        end do\n    end do\n    print*,\n    print*,&quot;------------------------------------------------------&quot;\n    print*,&quot;          No Pivot A=LU factorized array&quot;\n    print*,&quot;-------------------------------------------------------&quot;\n    print*,\n    do i=1,m\n        print*,A(i,:)\n    end do\n    print*,\n    print*,&quot;*******************************************************&quot;\n    print*,&quot;       Checking Correctness of the factorization&quot;\n    print*,&quot;*******************************************************&quot;\n    print*,\n    call CheckingNoPivot(m,n,A,A1)\nend subroutine\n\nsubroutine CheckingNoPivot(m,n,A,A1)\n    integer,intent(in)::m,n\n    doubleprecision,dimension(m,n),intent(inout)::A,A1\n    doubleprecision,dimension(n,n):: U\n    doubleprecision,dimension(m,n)::L,A2\n    integer::i,j\n\n    do i=1,m\n        do j=1,n\n            if(i.le.j)then\n                L(i,j)=0\n            else if (i.gt.j) then\n                L(i,j)=A(i,j)\n            end if\n            L(i,i)=1\n        end do\n    end do\n    do i=1,n\n        do j=1,n\n            if(i.le.j)then\n                U(i,j)=A(i,j)\n            else\n                U(i,j)=0.0\n            end if\n        end do\n    end do\n    print*,\n    print*, &#39;----------------------------------------------&#39;\n    print*,&quot;  No Pivot Upper triangular matrix U&quot;\n    print*, &#39;----------------------------------------------&#39;\n    print*,\n    do i=1,n\n        print*,U(i,:)\n    end do\n    print*,\n    print*, &#39;----------------------------------------------&#39;\n    print*,&quot;  No Pivot Lower triangular matrix L&quot;\n    print*, &#39;----------------------------------------------&#39;\n    print*,\n    do i=1,m\n        print*,L(i,:)\n    end do\n\n    A2=matmul(L,U)\n    print*,\n    print*, &#39;----------------------------------------------&#39;\n    print*,&quot;       No Pivot Product of L U=&quot;\n    print*, &#39;----------------------------------------------&#39;\n    print*,\n    do i=1,m\n        print*,A2(i,:)\n    end do\n    print*,\n    print*, &#39;----------------------------------------------&#39;\n    print*, &quot;  Factoring Accuracy with the Frobenius Norm&quot;\n    print*, &#39;----------------------------------------------&#39;\n    print*,\n    print*,&quot;Relative Error=&quot;,Frobenius(m,n,A1-A2)/Frobenius(m,n,A1)\n    print*\n    print*, &quot;Growth Factor=&quot;, Frobenius(m,n,matmul(abs(L),abs(U)))/Frobenius(m,n,A1)\n    print*,\n    print*, &#39;----------------------------------------------&#39;\n    print*, &quot;     Factoring Accuracy with the 1-Norm&quot;\n    print*, &#39;----------------------------------------------&#39;\n    print*,\n    print*,&quot;Relative Error=&quot;,norm1(m,n,A1-A2)/norm1(m,n,A1)\n    print*\n    print*, &quot;Growth Factor=&quot;, norm1(m,n,matmul(abs(L),abs(U)))/norm1(m,n,A1)\n    print*,\n    print*, &#39;----------------------------------------------&#39;\n    print*, &quot;     Factoring Accuracy with the Infinity-Norm&quot;\n    print*, &#39;----------------------------------------------&#39;\n    print*,\n    print*,&quot;Relative Error=&quot;,infinityNorm(m,n,A1-A2)/infinityNorm(m,n,A1)\n    print*\n    print*, &quot;Growth Factor=&quot;, infinityNorm(m,n,matmul(abs(L),abs(U)))/infinityNorm(m,n,A1)\nend subroutine\n\nsubroutine max_val(A,m,n,k,row,col)\n    implicit none\n    integer,intent(in)::m,n,k\n    integer,intent(out)::row,col\n    doubleprecision,dimension(m,n),intent(inout)::A\n    doubleprecision::maximum\n    integer::i,j\n\n    maximum=maxval(A(k:m,k:n))\n\n    do i=k,m\n        do j=k,n\n            if(A(i,j)==maximum) then\n                row=i\n                col=j\n                goto 100\n            end if\n        end do\n    end do\n100 end subroutine\n\nsubroutine max_valP(A,m,n,k,row)\n    implicit none\n    integer,intent(in)::m,n,k\n    integer,intent(out)::row\n    doubleprecision,dimension(m,n),intent(inout)::A\n    doubleprecision::maximum\n    integer::i,j\n\n    maximum=maxval(A(k:m,k))\n\n    do i=k,m\n        if(A(i,k)==maximum) then\n            row=i\n            goto 101\n        end if\n    end do\n101 end subroutine\n\n\nfunction norm1(m,n,A)\n    integer::m,n,i,j\n    doubleprecision,dimension(m,n)::A\n    doubleprecision,dimension(n):: normvector\n    doubleprecision::normval\n\n    normval=0\n    do j=1,n\n        do i=1,m\n            normval=normval+abs(A(i,j))\n        end do\n        normvector(j)=normval\n    end do\n    norm1=maxval(normvector(1:n))\n    return\nend function\n\nfunction infinityNorm(m,n,A)\n    integer::m,n,i,j\n    doubleprecision,dimension(m,n)::A\n    doubleprecision,dimension(n):: normvector\n    doubleprecision:: normval\n\n    normval=0\n    do j=1,n\n        do i=1,m\n            normval=normval+abs(A(i,j))\n            normvector(j)=normval\n        end do\n    end do\n    infinityNorm=maxval(normvector(1:m))\n    return\nend function\n\nfunction Frobenius(m,n,A)\n    integer::m,n,i,j\n    doubleprecision,dimension(m,n)::A\n    doubleprecision:: normval\n\n    normval=0\n    do i=1,m\n        do j=1,n\n            normval=normval+(abs(A(i,j)))**2\n        end do\n    end do\n    Frobenius=sqrt(normval)\n    return\nend function"
  },
  {
    "objectID": "posts/lu/index.html#no-pivot",
    "href": "posts/lu/index.html#no-pivot",
    "title": "LU Factorization of a Full rank Matrix using Fortran",
    "section": "No Pivot",
    "text": "No Pivot\nInput Matrix (Stored in a data file in the same directory where the program file .f90 located)\n8 2 9\n4 9 4\n6 7 9\n\nComand prompt: \n Input the number of rows of the matrix A, m\n3\n Input the number of columns of the matrix A, n\n3\n\n\n This is the provided working matrix\n\n   8.0000000000000000        2.0000000000000000        9.0000000000000000\n   4.0000000000000000        9.0000000000000000        4.0000000000000000\n   6.0000000000000000        7.0000000000000000        9.0000000000000000\n\n What method you want to apply?\n For No Pivot input: N\n For Partial Pivot input: P\n For Complete Pivot input: C\nn\n No Pivoting method has been selected\n\n\n ------------------------------------------------------\n           No Pivot A=LU factorized array\n -------------------------------------------------------\n\n   8.0000000000000000        2.0000000000000000        9.0000000000000000\n  0.50000000000000000        8.0000000000000000      -0.50000000000000000\n  0.75000000000000000       0.68750000000000000        2.5937500000000000\n\n *******************************************************\n        Checking Correctness of the factorization\n *******************************************************\n\n\n ----------------------------------------------\n   No Pivot Upper triangular matrix U\n ----------------------------------------------\n\n   8.0000000000000000        2.0000000000000000        9.0000000000000000\n   0.0000000000000000        8.0000000000000000      -0.50000000000000000\n   0.0000000000000000        0.0000000000000000        2.5937500000000000\n\n ----------------------------------------------\n   No Pivot Lower triangular matrix L\n ----------------------------------------------\n\n   1.0000000000000000        0.0000000000000000        0.0000000000000000\n  0.50000000000000000        1.0000000000000000        0.0000000000000000\n  0.75000000000000000       0.68750000000000000        1.0000000000000000\n\n ----------------------------------------------\n        No Pivot Product of L U=\n ----------------------------------------------\n\n   8.0000000000000000        2.0000000000000000        9.0000000000000000\n   4.0000000000000000        9.0000000000000000        4.0000000000000000\n   6.0000000000000000        7.0000000000000000        9.0000000000000000\n\n ----------------------------------------------\n   Factoring Accuracy with the Frobenius Norm\n ----------------------------------------------\n\n Relative Error=   0.00000000\n\n Growth Factor=   1.02520537\n\n ----------------------------------------------\n      Factoring Accuracy with the 1-Norm\n ----------------------------------------------\n\n Relative Error=           0\n\n Growth Factor=           1\n\n ----------------------------------------------\n      Factoring Accuracy with the Infinity-Norm\n ----------------------------------------------\n\n Relative Error=           0\n\n Growth Factor=           1"
  },
  {
    "objectID": "posts/lu/index.html#partial-pivot",
    "href": "posts/lu/index.html#partial-pivot",
    "title": "LU Factorization of a Full rank Matrix using Fortran",
    "section": "Partial Pivot",
    "text": "Partial Pivot\nInput Matrix (Stored in a data file in the same directory where the program file .f90 located)\n1 2 4\n2 1 3\n3 2 4\n\nComand Prompt: \n Input the number of rows of the matrix A, m\n3\n Input the number of columns of the matrix A, n\n3\n\n\n This is the provided working matrix\n\n   1.0000000000000000        2.0000000000000000        4.0000000000000000\n   2.0000000000000000        1.0000000000000000        3.0000000000000000\n   3.0000000000000000        2.0000000000000000        4.0000000000000000\n\n What method you want to apply?\n For No Pivot input: N\n For Partial Pivot input: P\n For Complete Pivot input: C\np\n Partial Pivoting method has been selected\n\n\n ------------------------------------------------------\n           Partial Pivot A=LU factorized array\n -------------------------------------------------------\n\n   3.0000000000000000        2.0000000000000000        4.0000000000000000\n  0.66666666666666663        1.3333333333333335        2.6666666666666670\n  0.33333333333333331      -0.24999999999999992        1.0000000000000000\n\n Permutation vector P=(           3           3 )\n\n *******************************************************\n        Checking Correctness of the factorization\n *******************************************************\n\n\n ----------------------------------------------\n   Partial Pivot Upper triangular matrix U\n ----------------------------------------------\n\n   3.0000000000000000        2.0000000000000000        4.0000000000000000\n   0.0000000000000000        1.3333333333333335        2.6666666666666670\n   0.0000000000000000        0.0000000000000000        1.0000000000000000\n\n ----------------------------------------------\n   Partial Pivot Lower triangular matrix L\n ----------------------------------------------\n\n   1.0000000000000000        0.0000000000000000        0.0000000000000000\n  0.66666666666666663        1.0000000000000000        0.0000000000000000\n  0.33333333333333331      -0.24999999999999992        1.0000000000000000\n\n ----------------------------------------------\n        Partial Pivot Product of L U=\n ----------------------------------------------\n\n   3.0000000000000000        2.0000000000000000        4.0000000000000000\n   2.0000000000000000        2.6666666666666670        5.3333333333333339\n   1.0000000000000000       0.33333333333333337        1.6666666666666667\n\n ----------------------------------------------\n  Factoring Accuracy with the Frobenius-Norm\n ----------------------------------------------\n\n Relative Error=  0.618016541\n\n Growth Factor=   1.11492395\n\n ----------------------------------------------\n      Factoring Accuracy with the 1-Norm\n ----------------------------------------------\n\n Relative Error=           0\n\n Growth Factor=           1\n\n ----------------------------------------------\n      Factoring Accuracy with the Infinity-Norm\n ----------------------------------------------\n\n Relative Error=           0\n\n Growth Factor=           1"
  },
  {
    "objectID": "posts/lu/index.html#complete-pivot",
    "href": "posts/lu/index.html#complete-pivot",
    "title": "LU Factorization of a Full rank Matrix using Fortran",
    "section": "Complete Pivot",
    "text": "Complete Pivot\nInput Matrix (Stored in a data file in the same directory where the program file .f90 located)\n  \n2 3 4\n4 7 5\n4 9 5\n\nCommand Prompt:\n Input the number of rows of the matrix A, m\n3\n Input the number of columns of the matrix A, n\n3\n\n\n This is the provided working matrix\n\n   2.0000000000000000        3.0000000000000000        4.0000000000000000\n   4.0000000000000000        7.0000000000000000        5.0000000000000000\n   4.0000000000000000        9.0000000000000000        5.0000000000000000\n\n What method you want to apply?\n For No Pivot input: N\n For Partial Pivot input: P\n For Complete Pivot input: C\nc\n Complete Pivoting method has been selected\n\n\n ------------------------------------------------------\n          Complete Pivot A=LU factorized array\n -------------------------------------------------------\n\n   9.0000000000000000        4.0000000000000000        5.0000000000000000\n  0.77777777777777779        2.3333333333333335       0.66666666666666674\n  0.33333333333333331       0.47619047619047616       0.57142857142857140\n\n Permutation vector P=(           3           3 )\n\n Permutation vector Q=(           2           3 )\n\n *******************************************************\n        Checking Correctness of the factorization\n *******************************************************\n\n\n ----------------------------------------------\n   Complete Pivot Upper triangular matrix U\n ----------------------------------------------\n\n   9.0000000000000000        4.0000000000000000        5.0000000000000000\n   0.0000000000000000        2.3333333333333335       0.66666666666666674\n   0.0000000000000000        0.0000000000000000       0.57142857142857140\n\n ----------------------------------------------\n   Complete Pivot Lower triangular matrix L\n ----------------------------------------------\n\n   1.0000000000000000        0.0000000000000000        0.0000000000000000\n  0.77777777777777779        1.0000000000000000        0.0000000000000000\n  0.33333333333333331       0.47619047619047616        1.0000000000000000\n\n ----------------------------------------------\n               Product of L U=\n ----------------------------------------------\n\n   9.0000000000000000        4.0000000000000000        5.0000000000000000\n   7.0000000000000000        5.4444444444444446        4.5555555555555554\n   3.0000000000000000        2.4444444444444442        2.5555555555555554\n\n ----------------------------------------------\n   Factoring Accuracy with the Frobenius-Norm\n ----------------------------------------------\n\n Relative Error=  0.683437467\n\n Growth Factor=   1.00393677\n\n ----------------------------------------------\n      Factoring Accuracy with the 1-Norm\n ----------------------------------------------\n\n Relative Error=           0\n\n Growth Factor=           1\n\n ----------------------------------------------\n      Factoring Accuracy with the Infinity-Norm\n ----------------------------------------------\n\n Relative Error=           0\n\n Growth Factor=           1\nShare on\n\n\n\n\n\n\nShare\n\n\n\nTweet\n\n\n\n\n\nYou may also like"
  },
  {
    "objectID": "posts/matrix-rep/index.html",
    "href": "posts/matrix-rep/index.html",
    "title": "Matrix Representation: Change of Basis",
    "section": "",
    "text": "Let \\(\\alpha: \\mathcal{P}_2(\\mathbb{R}) \\longrightarrow M_{2\\times 2}(\\mathbb{R})\\) be defined by\n\n\n\\(\\alpha(f(x))=\\left(\\begin{array}{cc}f^{'}(0)& 2f(1)\\\\0& f^{''}(3)\\end{array}\\right)\\)\n\n\nFirst, let’s show that \\(\\alpha\\) is a linear transformation. Let \\(f(x),g(x) \\in \\mathcal{P}_2(\\mathbb{R})\\) and \\(a,b\\in \\mathbb{R}\\). Then by definition, we have\n\n\n\\(\\alpha(af(x)+bg(x))=\\left(\\begin{array}{cc}af'(0)+bg'(0)& 2af(1)+2bg(1)\\\\0& af''(3)+bg''(3)\\end{array}\\right)\\)\n\n\n\n\n\n\\(\\hspace{1.6in}\\)=\\(\\left(\\begin{array}{cc}af'(0)& 2af(1)\\\\0& af''(3)\\end{array}\\right)\\)+\\(\\left(\\begin{array}{cc}bg'(0)& 2bg(1)\\\\0& bg''(3)\\end{array}\\right)\\)\n\n\n\n\n\n\\(\\hspace{1.6in}\\)=\\(a\\left(\\begin{array}{cc}f'(0)& 2f(1)\\\\0& f''(3)\\end{array}\\right)\\)+\\(b\\left(\\begin{array}{cc}g'(0)& 2g(1)\\\\0& g''(3)\\end{array}\\right)\\)\n\n\n\n\n\n\\(\\hspace{1.6in}=a\\alpha(f(x))+b\\alpha(g(x))\\)\n\n\nSo that \\(\\alpha\\) is a linear transformation.\n\n\nSecond, we find the kernel space \\(ker(\\alpha)\\), then use the Dimension Theorem (formula) to decide the rank of \\(\\alpha\\)\n\n\nThe kernel of \\(\\alpha\\) is defined as\n\n\n\\(ker(\\alpha)=\\{v\\in V|\\alpha(v)=0_{M_{2\\times2}(\\mathbb{R})}\\}\\)\n\n\n\n\n\n\\(\\alpha(f(x))=\\left(\\begin{array}{cc}f^{'}(0)& 2f(1)\\\\0& f^{''}(3)\\end{array}\\right)=[0]\\)\n\n\n\\(\\implies f'(0)=0, 2f(1)=0, f''(3)=0\\)\n\n\nIf \\(f(x)=a+bx+cx^2\\) then we have,\n\n\n\\(\\begin{array}{c}f'(0)\\implies b=0\\\\2f(1)=0\\implies 2(a+b+c)=0\\\\f''(3)=0\\implies 2c=0\\end{array}\\)\n\n\n\\(\\implies a=b=c=0 \\implies ker(\\alpha)=\\{0_{\\mathcal{P}_2(\\mathbb{R})}\\}\\)\n\n\nThen \\(nullity(\\alpha)=\\dim ker(\\alpha)=0\\) and if we use the dimension formula then, \\(rank(\\alpha)=\\dim \\mathcal{P}_2(\\mathbb{R})-nullity(\\alpha)=3-0=3\\)\n\n\nThird, we will find the representation matrix \\(\\phi_{BD}(\\alpha)\\), where \\(B=\\{1+x,1-x,x^2\\}\\) is an ordered basis for \\(\\mathcal{P}_2(\\mathbb{R})\\)\n\n\nand\n\n\\(D=\\begin{Bmatrix}\\begin{bmatrix}1 & 0\\\\0 &0\\end{bmatrix},\\begin{bmatrix}0 & 1\\\\0 &0\\end{bmatrix},\\begin{bmatrix}0 & 0\\\\1 &0\\end{bmatrix},\\begin{bmatrix}0 & 0\\\\0 &1\\end{bmatrix}\\end{Bmatrix}\\)\nis an ordered basis for \\(\\mathbf{M}_{2\\times 2}(\\mathbb{R})\\)\n\n\n\nNow if \\(f(x)=1+x\\) then\n\n\n\\(\\alpha(f(x))=\\left(\\begin{array}{cc}f^{'}(0)& 2f(1)\\\\0& f^{''}(3)\\end{array}\\right)\\)\n\n\n\n\n\n\\(\\hspace{1in}=\\left(\\begin{array}{cc}1& 4\\\\0& 0\\end{array}\\right)\\)\n\n\n\n\n\n\\(\\hspace{1in}=\\left(\\begin{array}{c}1\\\\4\\\\0\\\\0\\end{array}\\right)\\)\n\n\n\n\n\n\nNow if \\(f(x)=1-x\\) then\n\n\n\\(\\alpha(f(x))=\\left(\\begin{array}{cc}f^{'}(0)& 2f(1)\\\\0& f^{''}(3)\\end{array}\\right)\\)\n\n\n\n\n\n\\(\\hspace{1in}=\\left(\\begin{array}{cc}-1& 0\\\\0& 0\\end{array}\\right)\\)\n\n\n\n\n\n\\(\\hspace{1in}=\\left(\\begin{array}{c}-1\\\\0\\\\0\\\\0\\end{array}\\right)\\)\n\n\n\n\n\n\nNow if \\(f(x)=x^2\\) then\n\n\n\\(\\alpha(f(x))=\\left(\\begin{array}{cc}f^{'}(0)& 2f(1)\\\\0& f^{''}(3)\\end{array}\\right)\\)\n\n\n\n\n\n\\(\\hspace{1in}=\\left(\\begin{array}{cc}0& 2\\\\0& 2\\end{array}\\right)\\)\n\n\n\n\n\n\\(\\hspace{1in}=\\left(\\begin{array}{c}-2\\\\2\\\\0\\\\2\\end{array}\\right)\\)\n\n\n\n\n\nbecause,\n\n\n\n\n\n\n\\(\\left(\\begin{array}{cc}0& 2\\\\0& 2\\end{array}\\right)\\)\\(=-2\\left(\\begin{array}{cc}1& 0\\\\0& 0\\end{array}\\right)\\)\\(+2\\left(\\begin{array}{cc}0& 1\\\\0& 0\\end{array}\\right)\\)\\(+0\\left(\\begin{array}{cc}0& 0\\\\1& 0\\end{array}\\right)\\)\\(+2\\left(\\begin{array}{cc}1& 0\\\\0& 1\\end{array}\\right)\\)\n\n\n\n\n\nTherefore, \\(\\phi_{BD}(\\alpha)=\\)\\(\\left(\\begin{array}{ccc}1& -1& -2\\\\4& 0& 2\\\\0& 0& 0\\\\0& 0& 2\\end{array}\\right)\\)\n\n\n\n\n\n\n\n\n\n\nShare on\n\n\n\n\n\n\n\nShare\n\n\n\nTweet\n\n\n\n\n\nYou may also like\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGeneralized eigenvectors and eigenspaces\n\n\n2 min\n\n\n\nRafiq Islam\n\n\nMonday, January 25, 2021\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHow to generate social share buttons\n\n\n2 min\n\n\n\nRafiq Islam\n\n\nWednesday, July 17, 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLU Factorization of a Full rank Matrix using Fortran\n\n\n26 min\n\n\n\nRafiq Islam\n\n\nTuesday, November 9, 2021\n\n\n\n\n\n\n\n\nNo matching items\n\n Back to topCitationBibTeX citation:@online{islam2021,\n  author = {Islam, Rafiq},\n  title = {Matrix {Representation:} {Change} of {Basis}},\n  date = {2021-01-21},\n  url = {https://mrislambd.github.io/posts/matrix-rep/},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nIslam, Rafiq. 2021. “Matrix Representation: Change of\nBasis.” January 21, 2021. https://mrislambd.github.io/posts/matrix-rep/."
  },
  {
    "objectID": "posts/eigen/index.html",
    "href": "posts/eigen/index.html",
    "title": "Generalized eigenvectors and eigenspaces",
    "section": "",
    "text": "Definition: Let \\(\\alpha\\in End(V)\\) and \\(\\lambda\\in spec(\\alpha)\\). A non-zero vector \\(v\\) is called a generalized eigenvector vector of \\(\\alpha\\) associated with \\(\\lambda\\) if \\((\\alpha-\\lambda I)^{k}(v)=0\\) and \\((\\alpha-\\lambda I)^{k-1}(v)\\ne 0\\) for some \\(k\\ge 1\\) where \\(k\\) is called the degree of nilpotence for \\(v\\).\n\n\nLet \\(\\lambda\\in spec(\\alpha)\\). Then, \\(M_{\\lambda}=\\bigcup\\limits_{m=1} ker(\\lambda I-\\alpha)^m\\) is what we call it the generalized eigenspace corresponding to \\(\\lambda\\). Clearly, \\(M_{\\lambda}\\) is the union of the zero vector and the set of all generalized eigenvectors of \\(\\alpha\\) associated with \\(\\lambda\\)\n\n\nFact: \\(M_{\\lambda}\\) is a subspace and \\(\\alpha-\\)invariant and if \\(v\\) is a generalized vector of index \\(k\\) then \\(\\{v,(\\alpha-\\lambda I)v,\\cdots, (\\alpha-\\lambda I)^{k-1}v\\}\\) is linearly independent.\n\n\nProof: Let \\(a\\in \\mathbb{F}\\) and let \\(v,w\\in V\\) be generalized eigenvectors of \\(\\alpha\\) associated with \\(\\lambda\\) of degrees \\(k\\) and \\(h\\) respectively. Then,\n\n\n\\((\\alpha-\\lambda I)^k(v)=0\\) and \\((\\alpha-\\lambda I)^h(w)=0\\)\n\n\n\\(\\implies v\\in ker (\\alpha-\\lambda I)^k\\) and \\(w\\in ker(\\alpha-\\lambda I)^h\\)\n\n\n\\(\\implies v\\in ker (\\alpha-\\lambda I)^{k+h}\\) and \\(w\\in ker(\\alpha-\\lambda I)^{k+h}\\) because \\((\\alpha-\\lambda I)^{k+h}(v)=0\\) and \\((\\alpha-\\lambda I)^{k+h}(w)=0\\)\n\n\n\\(\\implies v+w \\in ker(\\alpha-\\lambda)^{k+h}\\)\n\n\nAnd, \\((\\alpha-\\lambda I)^{k+h}(av)=a.(\\alpha-\\lambda I)^{k+h}(v)=0\\).\n\n\nThis implies that \\(M_{\\lambda}\\) is a subspace of \\(V\\).\n\n\nInvariance: If \\(\\beta\\in End(V)\\) commutes with \\(\\alpha\\) and if \\(v\\) is a generalized eigenvector of \\(\\alpha\\) associated with \\(\\lambda\\) such that \\(v\\in ker(\\alpha-\\lambda I)^k\\) then,\n\n\n\\((\\alpha-\\lambda I)^k\\beta(v)=\\beta(\\alpha-\\lambda I)^k(v)=0_V\\)\n\n\n\\(\\implies \\beta(v)\\) is also a generalized eigenvector of \\(\\alpha\\) associated with \\(\\lambda\\)\n\n\n\n\n\nLinearly Independence: If \\(v\\) is a generalized vector of \\(\\alpha\\) associated with \\(\\lambda\\) then \\((\\alpha-\\lambda I)^k(v)=0\\) and \\((\\alpha-\\lambda I)^{k-1}(v)\\ne 0\\). Now we assume that,\n\n\n\\(c_0v+c_1(\\alpha-\\lambda I)(v)+\\cdots+c_{k-1}(\\alpha-\\lambda I)^{k-1}(v)=0\\).\n\n\nWe need to show that \\(c_i's\\) are zero for \\(0\\le i\\le k-1\\).\n\n\nApplying \\((\\alpha-\\lambda)^{k-1}\\) we get,\n\n\n\\((\\alpha-\\lambda)^{k-1}(c_0v+c_1(\\alpha-\\lambda I)(v)+\\cdots+c_{k-1}(\\alpha-\\lambda I)^{k-1}(v))=0\\)\n\n\n\\(\\implies c_0(\\alpha-\\lambda I)^{k-1}(v)=0\\). Since \\((\\alpha-\\lambda I)^{k-1}(v)\\ne 0\\) so we get \\(c_0=0\\).\n\n\nSimilarly applying \\((\\alpha-\\lambda I)^{k-2},(\\alpha-\\lambda I)^{k-3},\\) and so on, we have\n\n\n\\(c_i=0\\) for \\(1\\le i\\le k-1\\).\n\n\nHence, \\(\\{v,(\\alpha-\\lambda I)v,\\cdots, (\\alpha-\\lambda I)^{k-1}v\\}\\) is linearly independent.\n\nShare on\n\n\n\n\n\n\nShare\n\n\n\nTweet\n\n\n\n\n\nYou may also like\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHow to generate social share buttons\n\n\n2 min\n\n\n\nRafiq Islam\n\n\nWednesday, July 17, 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLU Factorization of a Full rank Matrix using Fortran\n\n\n26 min\n\n\n\nRafiq Islam\n\n\nTuesday, November 9, 2021\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMatrix Representation: Change of Basis\n\n\n3 min\n\n\n\nRafiq Islam\n\n\nThursday, January 21, 2021\n\n\n\n\n\n\n\n\nNo matching items\n\n Back to topCitationBibTeX citation:@online{islam2021,\n  author = {Islam, Rafiq},\n  title = {Generalized Eigenvectors and Eigenspaces},\n  date = {2021-01-25},\n  url = {https://mrislambd.github.io/posts/eigen/},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nIslam, Rafiq. 2021. “Generalized Eigenvectors and\nEigenspaces.” January 25, 2021. https://mrislambd.github.io/posts/eigen/."
  },
  {
    "objectID": "posts/some-proofs/index.html",
    "href": "posts/some-proofs/index.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "posts/some-proofs/index.html#let-n-be-a-positive-integer.-show-that-every-matrix-a-in-m_n-times-nmathbbr-can-be-written-as-the-sum-of-two-non-singular-matrices.",
    "href": "posts/some-proofs/index.html#let-n-be-a-positive-integer.-show-that-every-matrix-a-in-m_n-times-nmathbbr-can-be-written-as-the-sum-of-two-non-singular-matrices.",
    "title": "",
    "section": "1. Let \\(n\\) be a positive integer. Show that every matrix \\(A \\in M_{n \\times n}(\\mathbb{R})\\) can be written as the sum of two non-singular matrices.",
    "text": "1. Let \\(n\\) be a positive integer. Show that every matrix \\(A \\in M_{n \\times n}(\\mathbb{R})\\) can be written as the sum of two non-singular matrices.\nProof: To prove this, we will use two known properties of matrices.\n\n\\(det(A)=\\) Product of the eigenvalues of \\(A\\)\n\nIf \\(\\lambda\\) is an eigenvalue of \\(A\\) then \\(\\lambda+n\\) is an eigenvalue of \\(A+nI\\) matrix.\n\nSince, \\(A\\in M_{n\\times n}(\\mathbb{R}),\\) let \\(\\lambda_i\\) for \\(1\\le i\\le n\\) be the eigenvalues of \\(A\\). The matrix \\(A+(n+1)I\\) has eigenvalues \\(\\lambda_{i+n+1}\\) for \\(1\\le i\\le n\\).\nLet,\n\\[\\begin{align*}\nn&=max\\{|\\lambda_i| : 1\\le i \\le n\\}\\\\\n\\implies& -n\\le \\lambda_i \\le n \\text{ for all }1\\le i \\le n\\\\\n\\implies& -n+n+1\\le \\lambda_i+n+1 \\le n+n+1\\text{ for all }1\\le i \\le n\\\\\n\\implies& 1\\le \\lambda_i+n+1 \\le 2n+1\\text{ for all }1\\le i \\le n\n\\end{align*}\\] Thus, \\(\\lambda_i+n+1\\ge 1\\) that is \\(\\lambda_i+n+1 \\ne 0\\) and \\(0\\) is not an eigenvalue of \\(A\\).\nNow, from property (1), we have,\n\\(det(A)=\\prod_{i=1}^{n}\\lambda_i\\)\nand\n\\[\\begin{align*}\ndet(A+(n+1)I)&=\\prod_{i=1}^{n}(\\lambda_i+n+1)\\ne 0\\\\\n\\end{align*}\\] \\(\\implies A\\text{ or }A+(n+1)I\\) both are non-singular.\n\\(-(n+1)I\\) is of course non-singular.\nThen\n\\(A=(A+(n+1)I)+(-(n+1)I)\\)"
  },
  {
    "objectID": "posts/some-proofs/index.html#let-alpha-in-mathcallv-and-dim-vn-infty",
    "href": "posts/some-proofs/index.html#let-alpha-in-mathcallv-and-dim-vn-infty",
    "title": "",
    "section": "2. Let \\(\\alpha \\in \\mathcal{L}(V)\\) and \\(\\dim V=n< \\infty\\)",
    "text": "2. Let \\(\\alpha \\in \\mathcal{L}(V)\\) and \\(\\dim V=n&lt; \\infty\\)\n\nSuppose that \\(\\alpha\\) has two distinct eigenvalues \\(\\lambda\\) and \\(\\mu\\). Prove that if \\(\\dim E_{\\lambda}=n-1\\) then \\(\\alpha\\) is diagonalizable.\n\n\nProof: Since \\(\\mu\\) and \\(\\lambda\\) are two distinct eigenvalues associated with \\(\\alpha\\), so \\(V=E_{\\lambda}\\bigoplus E_{\\mu}\\) and \\(\\dim E_{\\lambda}(\\alpha)+\\dim E_{\\mu}(\\alpha)=n\\).\n\n\nHere, \\(\\dim E_{\\mu}(\\alpha)\\ge 1\\) and \\(\\dim E_{\\lambda}(\\alpha)=n-1\\). So,\n\n\n\\(\\dim E_{\\lambda}(\\alpha)+\\dim E_{\\mu}(\\alpha)=n-1+1=n\\)"
  },
  {
    "objectID": "posts/some-proofs/index.html#let-alphain-mathcallv-and-0ne-vin-v-where-dim-vn-infty.",
    "href": "posts/some-proofs/index.html#let-alphain-mathcallv-and-0ne-vin-v-where-dim-vn-infty.",
    "title": "",
    "section": "3. Let \\(\\alpha\\in \\mathcal{L}(V)\\) and \\(0\\ne v\\in V\\) where \\(\\dim V=n< \\infty\\).",
    "text": "3. Let \\(\\alpha\\in \\mathcal{L}(V)\\) and \\(0\\ne v\\in V\\) where \\(\\dim V=n&lt; \\infty\\).\n\n\nProve that there is a unique monic polynomial \\(p(t)\\) of the smallest degree such that \\(p(\\alpha)(v)=0\\)\n\n\nProof: Since \\(V\\) is finite-dimensional so there exists smallest \\(k\\) such that \\(\\{v,\\alpha(v),\\cdots,\\alpha^{k-1}(v)\\}\\) is linearly independent but \\(\\{v,\\alpha(v),\\cdots,\\alpha^{k-1}(v),\\alpha^k(v)\\}\\) is linearly dependent. So there exists \\(c_0,c_1,\\cdots,c_k\\in \\mathbb{F}\\) not all zero such that\n\n\n\\(c_0v+c_1\\alpha(v)+c_2\\alpha^2(v)+\\cdots+c_{k-1}\\alpha^{k-1}(v)+c_k\\alpha^k(v)=0\\)\n\n\nWithout loss of generality, let’s assume that \\(c_k\\ne 0\\). Then\n\n\n\\(a_0v+a_1\\alpha(v)+a_2\\alpha^2(v)+\\cdots+a_{k-1}\\alpha^{k-1}(v)+\\alpha^k(v)=0\\)\n\n\nwhere, \\(a_i=\\frac{c_i}{c_k}\\) for \\(1\\le i \\le k\\).\n\n\nThus, \\(p(t)=a_0+a_1t+a_2t^2+\\cdots+a_{k-1}t^{k-1}+t^k\\), a unique monic polynomial such that \\(p(\\alpha)(v)=0\\)\n\n\n\n\n\n(ii) Prove that \\(p(t)\\) from (i) divides the minimal polynomial of \\(\\alpha\\)\n\n\nProof: By polynomial division we have,\n\n\n\\(m(t)=p(t)h(t)+r(t)\\) where, \\(m(t)\\) is the minimal polynomial.\n\n\nThen, \\(m(\\alpha)(v)=p(\\alpha)h(\\alpha)(v)+r(\\alpha)(v)\\)\n\n\n\\(\\implies 0=0+r(\\alpha)(v)\\)\n\n\n\\(\\implies r(\\alpha)(v)=0\\)"
  },
  {
    "objectID": "posts/some-proofs/index.html#let-abin-m_ntimes-nmathbbf-such-that-there-exists-an-invertible-matrix-sin-m_ntimes-nmathbbf-such-that-sas-1-and-sbs-1-are-upper-triangular-matrices.-show-that-every-eigenvalue-of-ab-ba-is-zero",
    "href": "posts/some-proofs/index.html#let-abin-m_ntimes-nmathbbf-such-that-there-exists-an-invertible-matrix-sin-m_ntimes-nmathbbf-such-that-sas-1-and-sbs-1-are-upper-triangular-matrices.-show-that-every-eigenvalue-of-ab-ba-is-zero",
    "title": "",
    "section": "4. Let \\(A,B\\in M_{n\\times n}(\\mathbb{F})\\) such that there exists an invertible matrix \\(S\\in M_{n\\times n}(\\mathbb{F})\\) such that \\(SAS^{-1}\\) and \\(SBS^{-1}\\) are upper triangular matrices. Show that every eigenvalue of \\(AB-BA\\) is zero",
    "text": "4. Let \\(A,B\\in M_{n\\times n}(\\mathbb{F})\\) such that there exists an invertible matrix \\(S\\in M_{n\\times n}(\\mathbb{F})\\) such that \\(SAS^{-1}\\) and \\(SBS^{-1}\\) are upper triangular matrices. Show that every eigenvalue of \\(AB-BA\\) is zero\n\nProof: To prove the above statement, it is enough to show that \\(spec(AB-BA)=\\{0\\}\\)\n\n\nWe know that if \\(C\\) and \\(D\\) are upper triangular matrices then \\(spec(CD-DC)=\\{0\\}\\). Now let’s assume that \\(C=SAS^{-1}\\) and \\(D=SBS^{-1}\\). Then,\n\n\n\\(CD-DC=SAS^{-1}SBS^{-1}-SBS^{-1}SAS^{-1}\\)\n\n\n\\(\\implies CD-DC=SABS^{-1}-SBAS^{-1}\\)\n\n\n\\(\\implies CD-DC=S(AB-BA)S^{-1}\\)\n\n\nHence \\(CD-DC\\) and \\(AB-BA\\) are similar matrices. So they have the same eigenvalues, that is \\(spec(AB-BA)=\\{0\\}\\)."
  },
  {
    "objectID": "posts/some-proofs/index.html#caley-hamilton-theorem",
    "href": "posts/some-proofs/index.html#caley-hamilton-theorem",
    "title": "",
    "section": "5. Caley-Hamilton Theorem",
    "text": "5. Caley-Hamilton Theorem\n\nTheorem: Let \\(p(t)\\) be the characteristic polynomial of a matrix \\(A\\). Then \\(p(A)=0\\)\n\n\nBefore we start proving the theorem, we need to discuss some basics.\n\n\nFor Linear Operator: If \\(\\alpha\\in \\mathcal{L}(V)\\) and \\(A=\\Phi_{BB}(\\alpha)\\) is a representation matrix of \\(\\alpha\\) with respect to the basis \\(B\\), then \\(p(A)\\) is the representation matrix of \\(p(\\alpha)\\). Thus we also have \\(p(\\alpha)=0\\) if \\(p\\) is the characteristic polynomial of \\(\\alpha\\)\n\n\nAdjoint Matrix Method: If we have a matrix \\(A=[a_{ij}]\\in M_{n\\times n}(\\mathbb{F})\\) then we define the \\(\\textit{adjoint}\\) of \\(A\\) to be the matrix \\(adj(A)=[b_{ij}]\\in M_{n\\times n}(\\mathbb{F})\\), where \\(b_{ij}=(-1)^{i+j}|A_{ji}|\\) for all \\(1 \\le i,j \\le n\\)\n\n\nAnd, \\(A_{ji}\\) is the matrix obtained by deleting the i-th row and j-th column.\n\n\nExample: Let \\(A=\\left(\\begin{array}{ccc}1 &4 &7\\\\2 &5 &8\\\\3 &6 &9\\end{array}\\right)\\)\n\n\n\\(b_{11}=(-1)^{1+1}|A_{11}|=det\\left(\\begin{array}{cc}5 &8\\\\6 &9\\end{array}\\right)=-3\\)\n\n\n\\(b_{12}=(-1)^{1+2}|A_{21}|=-det\\left(\\begin{array}{cc}4 &7\\\\6 &9\\end{array}\\right)=6\\)\n\n\n\\(b_{13}=(-1)^{1+3}|A_{21}|=det\\left(\\begin{array}{cc}4 &7\\\\5 &8\\end{array}\\right)=-3\\)\n\n\n\\(b_{21}=(-1)^{2+1}|A_{12}|=-det\\left(\\begin{array}{cc}2 &8\\\\3 &9\\end{array}\\right)=6\\)\n\n\n\\(b_{22}=(-1)^{2+2}|A_{22}|=det\\left(\\begin{array}{cc}1 &7\\\\3 &9\\end{array}\\right)=-12\\)\n\n\n\\(b_{23}=(-1)^{2+3}|A_{32}|=-det\\left(\\begin{array}{cc}1 &7\\\\2 &8\\end{array}\\right)=6\\)\n\n\n\\(b_{31}=(-1)^{3+1}|A_{13}|=det\\left(\\begin{array}{cc}2 &5\\\\3 &6\\end{array}\\right)=-3\\)\n\n\n\\(b_{32}=(-1)^{3+2}|A_{23}|=-det\\left(\\begin{array}{cc}1 &4\\\\3 &6\\end{array}\\right)=6\\)\n\n\n\\(b_{33}=(-1)^{3+3}|A_{33}|=-det\\left(\\begin{array}{cc}1 &4\\\\2 &5\\end{array}\\right)=-3\\)\n\n\nThus,\n\n\n\\(adj(A)=\\left(\\begin{array}{ccc}-3 &6 &-3\\\\6 &-12 &6\\\\-3 &6 &-3\\end{array}\\right)\\).\n\n\nThe important formula that we are going to use is that,\n\n\n\\(AA^{-1}=I \\implies A\\frac{adj(A)}{det(A)}=I \\implies A.adj(A)=det(A).I\\) (*)\n\n\n\n\n\nProof: Let \\(A\\in M_{n\\times n}(\\mathbb{F})\\) have the minimal polynomial \\(p(t)=t^n+\\sum_{i=0}^{n-1}a_it^i\\).\n\n\nNow let, \\(adj(tI-A)=[g_{ij}(t)]=\\left(\\begin{array}{cccc}g_{11}(t) &g_{12}(t) &\\cdots &g_{1n}(t)\\\\g_{21}(t) &g_{22}(t) &\\cdots &g_{2n}(t)\\\\\\vdots &\\vdots &\\ddots &\\vdots\\\\g_{n1}(t) &g_{n2}(t) &\\cdots &g_{nn}(t)\\end{array}\\right)\\) be the adjoint matrix of \\((tI-A)\\).\n\n\nSince each \\(g_{ij}(t)\\) is a polynomial of degree at most \\(n-1\\), we can write this as, \\(adj(tI-A)=\\sum_{i=1}^{n}B_it^{n-i}\\) where \\(B_i\\in M_{n\\times n}(\\mathbb{F})\\).\n\n\nThen by (*) we have,\n\n\\[\\begin{align*}\np(t)I&=det(tI-A).I=(tI-A)adj(tI-A)=(tI-A)\\sum_{i=1}^{n}B_it^{n-i}\\\\\n\\implies& (a_0+a_1t+a_2t^2+\\cdots+a_{n-1}t^{n-1}+t^n)I=(tI-A)B_1t^{n-1}+\\cdots+(tI-A)B_{n-1}t+(tI-A)B_n\\\\\n\\implies& (a_0+a_1t+a_2t^2+\\cdots+a_{n-1}t^{n-1}+t^n)I=B_1t^n-AB_1t^{n-1}+B_2t^{n-1}-AB_2t^{n-2}+\\cdots+B_{n-1}t^2-AB_n\n\\end{align*}\\]\n\nBy comparing the coefficients, we get\n\n\n\\(B_1=I\\)\n\n\n\\(B_2-AB_1=a_{n-1}I\\)\n\n\n\\(B_3-AB_2=a_{n-2}I\\)\n\n\n\\(\\vdots\\)\n\n\n\\(B_n-AB_{n-1}=a_1I\\)\n\n\n\\(-AB_n=a_0I\\)\n\n\nNow multiply \\(A^{n+1-j}\\) to the \\(j-th\\) equation, and then sum up both sides we get,\n\n\n\\(A^{n+1-1}B_1=IA^{n+1-1}\\hspace{2.3in} \\implies A^nB_1=A^n\\)\n\n\n\\(A^{n+1-2}(B_2-AB_1)=a_{n-1}A^{n+1-2}\\hspace{1in} \\implies A^{n-1}B_2-AB_1=a_{n-1}A^{n-1}\\)\n\n\n\\(A^{n+1-3}(B_3-AB_2)=a_{n-2}A^{n+1-3}\\hspace{1in} \\implies A^{n-2}B_3-A^{n-1}B_2=a_{n-1}A^{n-2}\\)\n\n\n\\(\\vdots\\hspace{5in} \\vdots\\)\n\n\n\\(A^{n+1-n}(B_n-AB_{n-1})=a_1A^{n+1-n}\\hspace{1in} \\implies AB_n-A^2B_{n-1}=a_1A\\)\n\n\n\\(-AB_n=a_0I\\hspace{3.2in}\\implies -AB_n=a_0I\\)\n\n\nIf we add both sides then we obtain, \\(p(A)=0\\)"
  },
  {
    "objectID": "posts/some-proofs/index.html#prove-that-the-spectral-radius-of-the-textitmarkov-matrix-is-less-than-or-equal-to-1",
    "href": "posts/some-proofs/index.html#prove-that-the-spectral-radius-of-the-textitmarkov-matrix-is-less-than-or-equal-to-1",
    "title": "",
    "section": "6. Prove that the spectral radius of the \\(\\textit{Markov}\\) matrix is less than or equal to 1",
    "text": "6. Prove that the spectral radius of the \\(\\textit{Markov}\\) matrix is less than or equal to 1\n\nWe need to prove that if \\(A\\) is a Markov matrix then \\(\\rho(A)\\le 1\\). Now, what is a Markov matrix?\n\n\nMarkov Matrix: A matrix \\(A=[a_{i,j}]_{n\\times n}\\) is called a Markov matrix if \\(a_{i,j}\\ge 0\\) for all \\(1\\le i,j \\le n\\) and \\(\\sum_{j=1}^{n} a_i=1\\), that is the sum of the elements in any row is equal to 1.\n\n\nExample: If we have a matrix like this, \\(A=\\left(\\begin{array}{ccc}0.2 &0.4 &0.4\\\\0.1 &0.4 &0.5\\\\0.9 &0.1 &0\\end{array}\\right)\\) then \\(A\\) is a Markov matrix.\n\n\n\n\n\nProof: Let \\(\\lambda \\in spec(A)\\) and \\(x=\\left(\\begin{array}{c}x_1\\\\x_2\\\\\\vdots\\\\x_n\\end{array}\\right)\\ne 0\\) be a column vector. Then we define, \\(x_h=max\\{|x_i|: 1\\le i \\le n\\}\\) & \\(&gt;0\\). Here we are assuming \\(x_h &gt;0\\) because \\(x\\ne 0\\), as a result at least one of the coordinate of \\(x\\) must be greater than \\(0\\).\n\n\nNow,\n\n\n\\(Ax=\\lambda x=\\left(\\begin{array}{c}\\lambda x_1\\\\ \\lambda x_2 \\\\ \\vdots \\\\ \\lambda x_n\\end{array}\\right)\\)\n\n\n\\(\\implies \\lambda x_h =\\sum_{j=1}^{n} a_{hj}x_j\\)\n\n\n\\(\\implies |\\lambda x_h|=|\\lambda |.|x_h|=|\\sum_{j=1}^{n} a_{hj}x_j|\\le \\sum_{j=1}^{n} |a_{hj}| |x_j|\\)\n\n\n\\(\\implies |\\lambda |.|x_h| \\le (\\sum_{j=1}^{n} |a_{hj}|) |x_h|=1. |x_h|\\)\n\n\n\\(\\implies |\\lambda| \\le 1\\)\n\nShare on\n\n\n\n\n\n\n\nShare\n\n\n\nTweet\n\n\n\n\n\nYou may also like"
  }
]